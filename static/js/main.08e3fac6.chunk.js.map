{"version":3,"sources":["crypto/p2p.ts","crypto/transaction.ts","crypto/wallet.ts","crypto/transactionPool.ts","crypto/blockchain.ts","crypto/util.ts","App.js","serviceWorker.js","index.js","logo.svg"],"names":["MessageType","ec","ecdsa","UnspentTxOut","txOutId","txOutIndex","address","amount","this","TxIn","signature","TxOut","Transaction","id","txIns","txOuts","getTransactionId","transaction","txInContent","map","txIn","reduce","a","b","txOutContent","txOut","CryptoJS","toString","validateTransaction","aUnspentTxOuts","isValidTransactionStructure","console","log","validateTxIn","totalTxInValues","getTxInAmount","validateCoinbaseTx","blockIndex","length","referencedUTxOut","find","uTxO","JSON","stringify","keyFromPublic","verify","findUnspentTxOut","transactionId","index","getCoinbaseTransaction","t","processTransactions","aTransactions","coinbaseTx","slice","tx","validateBlockTransactions","newUnspentTxOuts","concat","consumedTxOuts","filter","updateUnspentTxOuts","toHexString","byteArray","Array","from","byte","join","getPublicKey","aPrivateKey","keyFromPrivate","getPublic","encode","isValidTxInStructure","isValidTxOutStructure","isValidAddress","match","startsWith","EC","getPrivateFromWallet","process","PRIVATE_KEY","cookie","Cookies","get","getPublicFromWallet","privateKey","key","generatePrivateKey","genKeyPair","getPrivate","findUnspentTxOuts","ownerAddress","unspentTxOuts","_","createTransaction","receiverAddress","txPool","myAddress","myUnspentTxOuts","currentAmount","includedUnspentTxOuts","myUnspentTxOut","push","leftOverAmount","eMsg","Error","findTxOutsForAmount","transactionPool","flatten","value","removable","unspentTxOut","undefined","aTxIn","filterTxPoolTxs","unsignedTxIns","txOut1","createTxOuts","txInIndex","dataToSign","referencedUnspentTxOut","referencedAddress","sign","toDER","signTxIn","getTransactionPool","setTransactionPool","addToTransactionPool","isValidTxForPool","hasTxIn","updateTransactionPool","invalidTxs","aTtransactionPool","txPoolIns","containsTxIn","txPoolIn","sockets","write","ws","message","send","broadcast","forEach","socket","responseLatestMsg","RESPONSE_BLOCKCHAIN","getLatestBlock","responseTransactionPoolMsg","RESPONSE_TRANSACTION_POOL","handleBlockchainResponse","receivedBlocks","latestBlockReceived","isValidBlockStructure","latestBlockHeld","hash","previousHash","addBlockToChain","QUERY_ALL","replaceChain","broadcastLatest","broadCastTransactionPool","Block","timestamp","data","difficulty","nonce","genesisBlock","blockchain","getBlockchain","getUnspentTxOuts","setUnspentTxOuts","newUnspentTxOut","getAdjustedDifficulty","latestBlock","aBlockchain","prevAdjustmentBlock","timeTaken","timeExpected","getCurrentTimestamp","Math","round","Date","getTime","generateRawNextBlock","blockData","previousBlock","getDifficulty","nextIndex","nextTimestamp","newBlock","findBlock","generateNextBlock","calculateHash","hashMatchesDifficulty","getAccountBalance","sum","sendTransaction","block","isValidNewBlock","isValidTimestamp","hasValidHash","getAccumulatedDifficulty","pow","hashMatchesBlockContent","calculateHashForBlock","hashInBinary","s","ret","lookupTable","i","hexToBinary","requiredPrefix","repeat","isValidChain","blockchainToValidate","currentBlock","retVal","newBlocks","io","transports","App","useState","first","setFirst","useCookies","cookies","setCookie","removeCookie","setPrivateKey","balance","setBalance","setTxPool","setAddress","setAmount","setBc","useEffect","jerry","emit","on","TxPool","bc","type","onChange","e","target","parseInt","onClick","item","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","module","exports"],"mappings":"iLAaKA,E,sHCTCC,EAAK,IAAIC,KAAS,aAIlBC,EAMF,WAAYC,EAAiBC,EAAoBC,EAAiBC,GAAiB,yBALnEH,aAKkE,OAJlEC,gBAIkE,OAHlEC,aAGkE,OAFlEC,YAEkE,EAC9EC,KAAKJ,QAAUA,EACfI,KAAKH,WAAaA,EAClBG,KAAKF,QAAUA,EACfE,KAAKD,OAASA,GAIhBE,E,sCACKL,a,OACAC,gB,OACAK,e,GAGLC,EAIF,WAAYL,EAAiBC,GAAiB,yBAHvCD,aAGsC,OAFtCC,YAEsC,EACzCC,KAAKF,QAAUA,EACfE,KAAKD,OAASA,GAIhBK,E,sCAEKC,Q,OAEAC,W,OACAC,Y,GAGLC,EAAmB,SAACC,GACtB,IAAMC,EAAsBD,EAAYH,MACnCK,KAAI,SAACC,GAAD,OAAgBA,EAAKhB,QAAUgB,EAAKf,cACxCgB,QAAO,SAACC,EAAGC,GAAJ,OAAUD,EAAIC,IAAG,IAEvBC,EAAuBP,EAAYF,OACpCI,KAAI,SAACM,GAAD,OAAkBA,EAAMnB,QAAUmB,EAAMlB,UAC5Cc,QAAO,SAACC,EAAGC,GAAJ,OAAUD,EAAIC,IAAG,IAE7B,OAAOG,SAAgBR,EAAcM,GAAcG,YAGjDC,EAAsB,SAACX,EAA0BY,GAEnD,IAAKC,EAA4Bb,GAC7B,OAAO,EAGX,GAAID,EAAiBC,KAAiBA,EAAYJ,GAE9C,OADAkB,QAAQC,IAAI,kBAAoBf,EAAYJ,KACrC,EAMX,IAJ+BI,EAAYH,MACtCK,KAAI,SAACC,GAAD,OAAUa,EAAab,EAAMH,EAAaY,MAC9CR,QAAO,SAACC,EAAGC,GAAJ,OAAUD,GAAKC,KAAG,GAI1B,OADAQ,QAAQC,IAAI,wCAA0Cf,EAAYJ,KAC3D,EAGX,IAAMqB,EAA0BjB,EAAYH,MACvCK,KAAI,SAACC,GAAD,OAAUe,EAAcf,EAAMS,MAClCR,QAAO,SAACC,EAAGC,GAAJ,OAAWD,EAAIC,IAAI,GAM/B,OAJiCN,EAAYF,OACxCI,KAAI,SAACM,GAAD,OAAWA,EAAMlB,UACrBc,QAAO,SAACC,EAAGC,GAAJ,OAAWD,EAAIC,IAAI,KAENW,IACrBH,QAAQC,IAAI,+CAAiDf,EAAYJ,KAClE,IA4CTuB,EAAqB,SAACnB,EAA0BoB,GAClD,OAAmB,MAAfpB,GACAc,QAAQC,IAAI,oEACL,GAEPhB,EAAiBC,KAAiBA,EAAYJ,IAC9CkB,QAAQC,IAAI,2BAA6Bf,EAAYJ,KAC9C,GAEsB,IAA7BI,EAAYH,MAAMwB,OAIlBrB,EAAYH,MAAM,GAAGT,aAAegC,GACpCN,QAAQC,IAAI,+DACL,GAEuB,IAA9Bf,EAAYF,OAAOuB,QACnBP,QAAQC,IAAI,qDACL,GAhJiB,KAkJxBf,EAAYF,OAAO,GAAGR,SACtBwB,QAAQC,IAAI,oDACL,QAbPD,QAAQC,IAAI,2DAkBdC,EAAe,SAACb,EAAYH,EAA0BY,GACxD,IAAMU,EACFV,EAAeW,MAAK,SAACC,GAAD,OAAUA,EAAKrC,UAAYgB,EAAKhB,SAAWqC,EAAKpC,aAAee,EAAKf,cAC5F,GAAwB,MAApBkC,EAEA,OADAR,QAAQC,IAAI,+BAAiCU,KAAKC,UAAUvB,KACrD,EAEX,IAAMd,EAAUiC,EAAiBjC,QAIjC,QAFYL,EAAG2C,cAActC,EAAS,OACFuC,OAAO5B,EAAYJ,GAAIO,EAAKV,aAE5DqB,QAAQC,IAAI,kDAAmDZ,EAAKV,UAAWO,EAAYJ,GAAI0B,EAAiBjC,UACzG,IAKT6B,EAAgB,SAACf,EAAYS,GAC/B,OAAOiB,EAAiB1B,EAAKhB,QAASgB,EAAKf,WAAYwB,GAAgBtB,QAGrEuC,EAAmB,SAACC,EAAuBC,EAAenB,GAC5D,OAAOA,EAAeW,MAAK,SAACC,GAAD,OAAUA,EAAKrC,UAAY2C,GAAiBN,EAAKpC,aAAe2C,MAGzFC,EAAyB,SAAC3C,EAAiB+B,GAC7C,IAAMa,EAAI,IAAItC,EACRQ,EAAa,IAAIX,EAQvB,OAPAW,EAAKV,UAAY,GACjBU,EAAKhB,QAAU,GACfgB,EAAKf,WAAagC,EAElBa,EAAEpC,MAAQ,CAACM,GACX8B,EAAEnC,OAAS,CAAC,IAAIJ,EAAML,EA3LM,KA4L5B4C,EAAErC,GAAKG,EAAiBkC,GACjBA,GA6CLC,EAAsB,SAACC,EAA8BvB,EAAgCQ,GAEvF,OArJ8B,SAACe,EAA8BvB,EAAgCQ,GAC7F,IAAMgB,EAAaD,EAAc,GACjC,OAAKhB,EAAmBiB,EAAYhB,GAgBMe,EAAcE,MAAM,GACpCnC,KAAI,SAACoC,GAAD,OAAQ3B,EAAoB2B,EAAI1B,MACzDR,QAAO,SAACC,EAAGC,GAAJ,OAAWD,GAAKC,KAAI,IAjB5BQ,QAAQC,IAAI,iCAAmCU,KAAKC,UAAUU,KACvD,GAiJNG,CAA0BJ,EAAevB,EAAgBQ,GArBtC,SAACe,EAA8BvB,GACvD,IAAM4B,EAAmCL,EACpCjC,KAAI,SAAC+B,GACF,OAAOA,EAAEnC,OAAOI,KAAI,SAACM,EAAOuB,GAAR,OAAkB,IAAI7C,EAAa+C,EAAErC,GAAImC,EAAOvB,EAAMnB,QAASmB,EAAMlB,cAE5Fc,QAAO,SAACC,EAAGC,GAAJ,OAAUD,EAAEoC,OAAOnC,KAAI,IAE7BoC,EAAiCP,EAClCjC,KAAI,SAAC+B,GAAD,OAAOA,EAAEpC,SACbO,QAAO,SAACC,EAAGC,GAAJ,OAAUD,EAAEoC,OAAOnC,KAAI,IAC9BJ,KAAI,SAACC,GAAD,OAAU,IAAIjB,EAAaiB,EAAKhB,QAASgB,EAAKf,WAAY,GAAI,MAMvE,OAJ+BwB,EAC1B+B,QAAQ,SAACnB,GAAD,OAAWK,EAAiBL,EAAKrC,QAASqC,EAAKpC,WAAYsD,MACnED,OAAOD,GAWLI,CAAoBT,EAAevB,IAHtCE,QAAQC,IAAI,8BACL,OAKT8B,EAAc,SAACC,GACjB,OAAOC,MAAMC,KAAKF,GAAW,SAACG,GAC1B,OAAQ,KAAc,IAAPA,GAAavC,SAAS,KAAK2B,OAAO,MAClDa,KAAK,KAGNC,EAAe,SAACC,GAClB,OAAOpE,EAAGqE,eAAeD,EAAa,OAAOE,YAAYC,OAAO,QAG9DC,EAAuB,SAACrD,GAC1B,OAAY,MAARA,GACAW,QAAQC,IAAI,iBACL,GAC0B,kBAAnBZ,EAAKV,WACnBqB,QAAQC,IAAI,mCACL,GACwB,kBAAjBZ,EAAKhB,SACnB2B,QAAQC,IAAI,iCACL,GAC4B,kBAApBZ,EAAKf,aACpB0B,QAAQC,IAAI,oCACL,IAMT0C,EAAwB,SAACjD,GAC3B,OAAa,MAATA,GACAM,QAAQC,IAAI,kBACL,GACyB,kBAAlBP,EAAMnB,SACpByB,QAAQC,IAAI,kCACL,GACC2C,EAAelD,EAAMnB,SAGE,kBAAjBmB,EAAMlB,SACpBwB,QAAQC,IAAI,iCACL,IAJPD,QAAQC,IAAI,0BACL,IASTF,EAA8B,SAACb,GACjC,MAA8B,kBAAnBA,EAAYJ,IACnBkB,QAAQC,IAAI,0BACL,GAELf,EAAYH,iBAAiBkD,QAI9B/C,EAAYH,MACRK,IAAIsD,GACJpD,QAAO,SAACC,EAAGC,GAAJ,OAAWD,GAAKC,KAAI,KAI9BN,EAAYF,kBAAkBiD,QAK/B/C,EAAYF,OACRI,IAAIuD,GACJrD,QAAO,SAACC,EAAGC,GAAJ,OAAWD,GAAKC,KAAI,IANhCQ,QAAQC,IAAI,sCACL,KAXPD,QAAQC,IAAI,sCACL,IAsBT2C,EAAiB,SAACrE,GACpB,OAAuB,MAAnBA,EAAQgC,QACRP,QAAQC,IAAI1B,GACZyB,QAAQC,IAAI,8BACL,GACoC,OAApC1B,EAAQsE,MAAM,mBACrB7C,QAAQC,IAAI,gDACL,KACC1B,EAAQuE,WAAW,QAC3B9C,QAAQC,IAAI,kCACL,I,iBCxUT8C,EAAK,IAAI7E,KAAG,aAEZ8E,GADqBC,wDAAYC,YACV,WAE1B,IAAIC,EAASC,IAAQC,IAAI,SAEzB,OADArD,QAAQC,IAAIkD,GACLA,IAGJG,EAAsB,WACxB,IAAMC,EAAaP,IACbQ,EAAMT,EAAGR,eAAegB,EAAY,OAE1C,OADAvD,QAAQC,IAAIuD,EAAIhB,aACTgB,EAAIhB,YAAYC,OAAO,QAG5BgB,EAAqB,WAIvB,OAFgBV,EAAGW,aACQC,aACT/D,SAAS,KA6BzBgE,EAAoB,SAACC,EAAsBC,GAC7C,OAAOC,SAASD,GAAe,SAACpD,GAAD,OAAwBA,EAAKnC,UAAYsF,MAmDtEG,EAAoB,SAACC,EAAyBzF,EAAgB+E,EACzCO,EAA+BI,GAEtDlE,QAAQC,IAAI,aAAcU,KAAKC,UAAUsD,IACzC,IAAMC,EAAoB9B,EAAakB,GAHsD,EAjDrE,SAAC/E,EAAgB4F,GACzC,IAAIC,EAAgB,EACdC,EAAwB,GAF+C,uBAG7E,YAA6BF,EAA7B,+CAA8C,CAAC,IAApCG,EAAmC,QAG1C,GAFAD,EAAsBE,KAAKD,IAC3BF,GAAgCE,EAAe/F,SAC1BA,EAEjB,MAAO,CAAC8F,wBAAuBG,eADRJ,EAAgB7F,IAP8B,kFAY7E,IAAMkG,EAAO,6FACalG,EAAS,6BAA+BmC,KAAKC,UAAUwD,GACjF,MAAMO,MAAMD,GA4CoCE,CAAoBpG,EA/BhD,SAACsF,EAA+Be,GACpD,IAAM9F,EAAgBgF,EAAEc,GACnBzF,KAAI,SAACoC,GAAD,OAAqBA,EAAGzC,SAC5B+F,UACAC,QACCC,EAA4B,GALqE,uBAMvG,IANuG,IAMvG,EANuG,iBAM5FC,EAN4F,aAWtFC,IAJAnB,OAAOhF,GAAO,SAACoG,GACxB,OAAOA,EAAM7G,aAAe2G,EAAa3G,YAAc6G,EAAM9G,UAAY4G,EAAa5G,YAMtF2G,EAAUR,KAAKS,IARvB,EAA2BnB,EAA3B,+CAA2C,IAN4D,kFAkBvG,OAAOC,UAAA,MAAAA,EAAC,CAASD,GAAT,OAA2BkB,IAUXI,CAFCtB,EAAcjC,QAAO,SAACnB,GAAD,OAAwBA,EAAKnC,UAAY4F,KAE7BD,IAGnDI,EATsF,EAStFA,sBAAuBG,EAT+D,EAS/DA,eASxBY,EAAwBf,EAAsBlF,KAP7B,SAAC6F,GACpB,IAAM5F,EAAa,IAAIX,EAGvB,OAFAW,EAAKhB,QAAU4G,EAAa5G,QAC5BgB,EAAKf,WAAa2G,EAAa3G,WACxBe,KAKLmC,EAAkB,IAAI3C,EAU5B,OATA2C,EAAGzC,MAAQsG,EACX7D,EAAGxC,OAtDc,SAACiF,EAAyBE,EAAmB3F,EAAQiG,GACtE,IAAMa,EAAgB,IAAI1G,EAAMqF,EAAiBzF,GACjD,OAAuB,IAAnBiG,EACO,CAACa,GAGD,CAACA,EADW,IAAI1G,EAAMuF,EAAWM,IAiDhCc,CAAatB,EAAiBE,EAAW3F,EAAQiG,GAC7DjD,EAAG1C,GAAKG,EAAiBuC,GAEzBA,EAAGzC,MAAQyC,EAAGzC,MAAMK,KAAI,SAACC,EAAY4B,GAEjC,OADA5B,EAAKV,UDgEI,SAACO,EAA0BsG,EAC1BjC,EAAoBzD,GAClC,IAAMT,EAAaH,EAAYH,MAAMyG,GAE/BC,EAAavG,EAAYJ,GACzB4G,EAAuC3E,EAAiB1B,EAAKhB,QAASgB,EAAKf,WAAYwB,GAC7F,GAA8B,MAA1B4F,EAEA,MADA1F,QAAQC,IAAI,mCACN0E,QAEV,IAAMgB,EAAoBD,EAAuBnH,QAEjD,GAAI8D,EAAakB,KAAgBoC,EAG7B,MAFA3F,QAAQC,IAAI,uGAEN0E,QAEV,IAAMnB,EAAMtF,EAAGqE,eAAegB,EAAY,OAG1C,OAF0BxB,EAAYyB,EAAIoC,KAAKH,GAAYI,SClFtCC,CAAStE,EAAIP,EAAOsC,EAAYO,GAC1CzE,KAGJmC,GCvIPqD,G,MAAiC,IAE/BkB,EAAqB,WACvB,OAAOhC,YAAYc,IAGjBmB,EAAqB,SAAE9B,GACzBW,EAAkBX,GAGhB+B,EAAuB,SAACzE,EAAiBsC,GAE3C,IAAKjE,EAAoB2B,EAAIsC,GACzB,MAAMa,MAAM,oCAGhB,IAAKuB,EAAiB1E,EAAIqD,GACtB,MAAMF,MAAM,oCAEhB3E,QAAQC,IAAI,uBAAwBU,KAAKC,UAAUY,IACnDqD,EAAgBL,KAAKhD,IAGnB2E,EAAU,SAAC9G,EAAYyE,GAIzB,YAAqBoB,IAHHpB,EAAcrD,MAAK,SAACC,GAClC,OAAOA,EAAKrC,UAAYgB,EAAKhB,SAAWqC,EAAKpC,aAAee,EAAKf,eAKnE8H,EAAwB,SAACtC,GAC3B,IAAMuC,EAAa,GAD0C,uBAE7D,YAAiBxB,EAAjB,+CAAkC,CAAC,IAAxBrD,EAAuB,+BAC9B,YAAmBA,EAAGzC,MAAtB,+CAA6B,CAAC,IAAnBM,EAAkB,QACzB,IAAK8G,EAAQ9G,EAAMyE,GAAgB,CAC/BuC,EAAW7B,KAAKhD,GAChB,QAJsB,oFAF2B,kFAUzD6E,EAAW9F,OAAS,IACpBP,QAAQC,IAAI,sDAAuDU,KAAKC,UAAUyF,IAClFxB,EAAkBd,UAAA,MAAAA,EAAC,CAASc,GAAT,OAA6BwB,MAWlDH,EAAmB,SAAC1E,EAAiB8E,GACvC,IAAMC,EAPCxC,EAOgCuC,GANlClH,KAAI,SAACoC,GAAD,OAAQA,EAAGzC,SACf+F,UACAC,QAMCyB,EAAe,SAACzH,EAAeM,GACjC,OAAO0E,OAAOwC,GAAY,SAACE,GACvB,OAAOpH,EAAKf,aAAemI,EAASnI,YAAce,EAAKhB,UAAYoI,EAASpI,YALC,uBASrF,YAAmBmD,EAAGzC,MAAtB,+CAA6B,CACzB,GAAIyH,EAAaD,EADQ,SAGrB,OADAvG,QAAQC,IAAI,qCACL,GAZsE,kFAerF,OAAO,GH5DLyG,EAAuB,I,SAExBzI,O,+BAAAA,I,yBAAAA,I,6CAAAA,I,mDAAAA,I,0DAAAA,M,SAgGC0I,EAAQ,SAACC,EAAeC,GAAhB,OAA2CD,EAAGE,KAAKnG,KAAKC,UAAUiG,KAC1EE,EAAY,SAACF,GAAD,OAA4BH,EAAQM,SAAQ,SAACC,GAAD,OAAYN,EAAMM,EAAQJ,OAUlFK,EAAoB,iBAAgB,CACtC,KAAQjJ,EAAYkJ,oBACpB,KAAQxG,KAAKC,UAAU,CAACwG,SAQtBC,EAA6B,iBAAgB,CAC/C,KAAQpJ,EAAYqJ,0BACpB,KAAQ3G,KAAKC,UAAUmF,OAYrBwB,GAA2B,SAACC,GAC9B,GAA8B,IAA1BA,EAAejH,OAAnB,CAIA,IAAMkH,EAA6BD,EAAeA,EAAejH,OAAS,GAC1E,GAAKmH,GAAsBD,GAA3B,CAIA,IAAME,EAAyBP,KAC3BK,EAAoBxG,MAAQ0G,EAAgB1G,OAC5CjB,QAAQC,IAAI,uCACN0H,EAAgB1G,MAAQ,cAAgBwG,EAAoBxG,OAC9D0G,EAAgBC,OAASH,EAAoBI,aACzCC,GAAgBL,IAChBV,EAAUG,KAEmB,IAA1BM,EAAejH,QACtBP,QAAQC,IAAI,4CACZ8G,EAlDwB,CAAC,KAAQ9I,EAAY8J,UAAW,KAAQ,SAoDhE/H,QAAQC,IAAI,yDACZ+H,GAAaR,KAGjBxH,QAAQC,IAAI,+EAnBZD,QAAQC,IAAI,oCALZD,QAAQC,IAAI,mCA4BdgI,GAAkB,WACpBlB,EAAUG,MAaRgB,GAA2B,WAC7BnB,EAAUM,MInLRc,GAUF,WAAYlH,EAAe2G,EAAcC,EAC7BO,EAAmBC,EAAqBC,EAAoBC,GAAgB,yBATjFtH,WASgF,OARhF2G,UAQgF,OAPhFC,kBAOgF,OANhFO,eAMgF,OALhFC,UAKgF,OAJhFC,gBAIgF,OAHhFC,WAGgF,EACnF9J,KAAKwC,MAAQA,EACbxC,KAAKoJ,aAAeA,EACpBpJ,KAAK2J,UAAYA,EACjB3J,KAAK4J,KAAOA,EACZ5J,KAAKmJ,KAAOA,EACZnJ,KAAK6J,WAAaA,EAClB7J,KAAK8J,MAAQA,GAafC,GAAsB,IAAIL,GAC5B,EAAG,mEAAoE,GAAI,WAAY,CAVhE,CACvB,MAAS,CAAC,CAAC,UAAa,GAAI,QAAW,GAAI,WAAc,IACzD,OAAU,CAAC,CACP,QAAW,qIACX,OAAU,KAEd,GAAM,qEAIuG,EAAG,GAGhHM,GAAsB,CAACD,IAGvB1E,GAAgC1C,EAAoBqH,GAAW,GAAGJ,KAAM,GAAI,GAE1EK,GAAgB,kBAAeD,IAO/BE,GAAmB,kBAAsB5E,YAAYD,KAGrD8E,GAAmB,SAACC,GACtB7I,QAAQC,IAAI,mCAAoC4I,GAChD/E,GAAgB+E,GAGdzB,GAAiB,kBAAaqB,GAAWA,GAAWlI,OAAS,IAiB7DuI,GAAwB,SAACC,EAAoBC,GAC/C,IAAMC,EAA6BD,EAAYP,GAAWlI,OAZf,IAcrC2I,EAAoBH,EAAYX,UAAYa,EAAoBb,UACtE,OAAIc,EAAYC,GACLF,EAAoBX,WAAa,EACjCY,EAAYC,IACZF,EAAoBX,WAAa,EAEjCW,EAAoBX,YAI7Bc,GAAsB,kBAAcC,KAAKC,OAAM,IAAIC,MAAOC,UAAY,MAEtEC,GAAuB,SAACC,GAC1B,IAAMC,EAAuBvC,KACvBkB,EA1BY,SAACU,GACnB,IAAMD,EAAqBC,EAAYP,GAAWlI,OAAS,GAC3D,OAAIwI,EAAY9H,MAJ2B,KAIgB,GAA2B,IAAtB8H,EAAY9H,MACjE6H,GAAsBC,EAAaC,GAEnCD,EAAYT,WAqBIsB,CAAclB,MACnCmB,EAAoBF,EAAc1I,MAAQ,EAC1C6I,EAAwBV,KACxBW,EAAkBC,GAAUH,EAAWF,EAAc/B,KAAMkC,EAAeJ,EAAWpB,GAC3F,OAAIR,GAAgBiC,IAChB9B,KACO8B,GAEA,MAUTE,GAAoB,WACtB,IACMP,EAA2B,CADDxI,EAAuBoC,IAAuB8D,KAAiBnG,MAAQ,IACzDU,OAAOoE,KACrD,OAAO0D,GAAqBC,IAgB1BM,GAAY,SAAC/I,EAAe4G,EAAsBO,EAAmBC,EAAqBC,GAE5F,IADA,IAAIC,EAAQ,IACC,CACT,IAAMX,EAAesC,GAAcjJ,EAAO4G,EAAcO,EAAWC,EAAMC,EAAYC,GACrF,GAAI4B,GAAsBvC,EAAMU,GAC5B,OAAO,IAAIH,GAAMlH,EAAO2G,EAAMC,EAAcO,EAAWC,EAAMC,EAAYC,GAE7EA,MAIF6B,GAAoB,WACtB,OFnGgB7L,EEmGE+E,IFnGeQ,EEmGQ6E,KFlGlC5E,EAAEH,EAAkBrF,EAASuF,IAC/B1E,KAAI,SAACsB,GAAD,OAAwBA,EAAKlC,UACjC6L,MAHU,IAAC9L,EAAiBuF,GEsG/BwG,GAAkB,SAAC/L,EAAiBC,GACtC,IAAMgD,EAAkBwC,EAAkBzF,EAASC,EAAQwE,IAAwB2F,KAAoB5C,KAGvG,OAFAE,EAAqBzE,EAAImH,MACzBT,KACO1G,GAML0I,GAAgB,SAACjJ,EAAe4G,EAAsBO,EAAmBC,EACxDC,EAAoBC,GADrB,OAElB5I,SAAgBsB,EAAQ4G,EAAeO,EAAYC,EAAOC,EAAaC,GAAO3I,YAE5E8H,GAAwB,SAAC6C,GAC3B,MAA8B,kBAAhBA,EAAMtJ,OACS,kBAAfsJ,EAAM3C,MACiB,kBAAvB2C,EAAM1C,cACc,kBAApB0C,EAAMnC,WACS,kBAAfmC,EAAMlC,MAGlBmC,GAAkB,SAACT,EAAiBJ,GACtC,OAAKjC,GAAsBqC,GAIvBJ,EAAc1I,MAAQ,IAAM8I,EAAS9I,OACrCjB,QAAQC,IAAI,kBACL,GACA0J,EAAc/B,OAASmC,EAASlC,cACvC7H,QAAQC,IAAI,yBACL,GACCwK,GAAiBV,EAAUJ,KAG3Be,GAAaX,IAFrB/J,QAAQC,IAAI,sBACL,IAXPD,QAAQC,IAAI,8BAA+BU,KAAKC,UAAUmJ,KACnD,IAiBTY,GAA2B,SAAC3B,GAC9B,OAAOA,EACF5J,KAAI,SAACmL,GAAD,OAAWA,EAAMjC,cACrBlJ,KAAI,SAACkJ,GAAD,OAAgBe,KAAKuB,IAAI,EAAGtC,MAChChJ,QAAO,SAACC,EAAGC,GAAJ,OAAUD,EAAIC,MAGxBiL,GAAmB,SAACV,EAAiBJ,GACvC,OAASA,EAAcvB,UAAY,GAAK2B,EAAS3B,WAC1C2B,EAAS3B,UAAY,GAAKgB,MAG/BsB,GAAe,SAACH,GAElB,OAAKM,GAAwBN,IAKxBJ,GAAsBI,EAAM3C,KAAM2C,EAAMjC,aACzCtI,QAAQC,IAAI,6CAA+CsK,EAAMjC,WAAa,QAAUiC,EAAM3C,OAE3F,IAPH5H,QAAQC,IAAI,qBAAuBsK,EAAM3C,OAClC,IASTiD,GAA0B,SAACN,GAE7B,OA9D0B,SAACA,GAAD,OAC1BL,GAAcK,EAAMtJ,MAAOsJ,EAAM1C,aAAc0C,EAAMnC,UAAWmC,EAAMlC,KAAMkC,EAAMjC,WAAYiC,EAAMhC,OA4D1EuC,CAAsBP,KAC3BA,EAAM3C,MAGzBuC,GAAwB,SAACvC,EAAcU,GACzC,IAAMyC,EChOU,SAACC,GAQjB,IAPA,IAAIC,EAAc,GACZC,EAAc,CAChB,EAAK,OAAQ,EAAK,OAAQ,EAAK,OAAQ,EAAK,OAAQ,EAAK,OACzD,EAAK,OAAQ,EAAK,OAAQ,EAAK,OAAQ,EAAK,OAAQ,EAAK,OACzD,EAAK,OAAQ,EAAK,OAAQ,EAAK,OAAQ,EAAK,OAC5C,EAAK,OAAQ,EAAK,QAEbC,EAAY,EAAGA,EAAIH,EAAEzK,OAAQ4K,GAAQ,EAAG,CAC7C,IAAID,EAAYF,EAAEG,IAGd,OAAO,KAFPF,GAAOC,EAAYF,EAAEG,IAK7B,OAAOF,EDiNsBG,CAAYxD,GACnCyD,EAAyB,IAAIC,OAAOhD,GAC1C,OAAOyC,EAAajI,WAAWuI,IAM7BE,GAAe,SAACC,GAClBxL,QAAQC,IAAI,iBACZD,QAAQC,IAAIU,KAAKC,UAAU4K,IAC3B,IAAwBjB,EAIxB,GAJwBA,EAIJiB,EAAqB,GAH9B7K,KAAKC,UAAU2J,KAAW5J,KAAKC,UAAU4H,IAIhD,OAAO,KAQX,IAFA,IAAI1I,EAAiC,GAE5BqL,EAAI,EAAGA,EAAIK,EAAqBjL,OAAQ4K,IAAK,CAClD,IAAMM,EAAsBD,EAAqBL,GACjD,GAAU,IAANA,IAAYX,GAAgBgB,EAAqBL,GAAIK,EAAqBL,EAAI,IAC9E,OAAO,KAIX,GAAuB,QADvBrL,EAAiBsB,EAAoBqK,EAAapD,KAAMvI,EAAgB2L,EAAaxK,QAGjF,OADAjB,QAAQC,IAAI,sCACL,KAGf,OAAOH,GAGLgI,GAAkB,SAACiC,GACrB,GAAIS,GAAgBT,EAAU3C,MAAmB,CAC7C,IAAMsE,EAAyBtK,EAAoB2I,EAAS1B,KAAMM,KAAoBoB,EAAS9I,OAC/F,OAAe,OAAXyK,GACA1L,QAAQC,IAAI,gDACL,IAEPwI,GAAWjE,KAAKuF,GAChBnB,GAAiB8C,GACjBtF,EAAsBtC,KACf,GAGf,OAAO,GAGLkE,GAAe,SAAC2D,GAClB,IAAM7L,EAAiByL,GAAaI,GACW,OAAnB7L,GAExB6K,GAAyBgB,GAAahB,GAAyBjC,OAC/D1I,QAAQC,IAAI,uFACZwI,GAAakD,EACb/C,GAAiB9I,GACjBsG,EAAsBtC,IACtBmE,MAEAjI,QAAQC,IAAI,gC,SEvRVgH,GAAS2E,IAAG,oCAAqC,CACrDC,WAAY,CAAC,eAmIJC,OAjIf,WAAgB,IAAD,EAEaC,mBAAS,GAFtB,mBAEJ1D,EAFI,aAGe0D,oBAAS,IAHxB,mBAGJC,EAHI,KAGGC,EAHH,OAIgCC,aAAW,CAAC,UAJ5C,mBAIJC,EAJI,KAIKC,EAJL,KAIgBC,EAJhB,OAKyBN,mBAAS,IALlC,mBAKJxI,EALI,KAKQ+I,EALR,OAMmBP,qBANnB,mBAMJQ,EANI,KAMKC,EANL,OAOiBT,mBAAShG,KAP1B,mBAOJ7B,EAPI,KAOIuI,EAPJ,OAQmBV,mBAAS,IAR5B,mBAQJxN,EARI,KAQKmO,EARL,OASiBX,mBAAS,GAT1B,mBASJvN,EATI,KASImO,EATJ,OAUSZ,mBAASrD,MAVlB,mBAUAkE,GAVA,WA0Eb,OA7DAC,qBAAU,WAsCJ,GArCA7M,QAAQC,IAAI,OAAQkM,EAAQW,OAIxBd,IACFhM,QAAQC,IAAI,iBACZgH,GAAO8F,KAAK,aACZ9F,GAAO8F,KAAK,iBACZd,GAAS,IAEXhF,GAAO+F,GAAG,aAAa,SAACC,GACpBjN,QAAQC,IAAI,YAAagN,GACzBjH,EAAmBiH,GACnBR,EAAUQ,MAEdhG,GAAO+F,GAAG,iBAAiB,SAACE,GAC1BlN,QAAQC,IAAI,UAAWiN,GACpBA,EAAG3M,OAAS,IACzBgH,GAAyB2F,GACxBN,EAAMM,OAIOjG,GAAO+F,GAAG,MAAM,SAACC,GACfjN,QAAQC,IAAI,YAAagN,GACzBjH,EAAmBiH,GACnBR,EAAUQ,MAEZhG,GAAO+F,GAAG,MAAM,SAACE,GACflN,QAAQC,IAAI,UAAWiN,GACnBA,EAAG3M,OAAS,IACdgH,GAAyB2F,GACzBN,EAAMM,YAKIhI,GAAjBiH,EAAQW,MAAoB,CAC7B,IAAItJ,EAAMC,IACAzD,QAAQC,IAAI,aAAcuD,GAC1B4I,EAAU,QAAS5I,GAE7B8I,EAAchJ,UAEdtD,QAAQC,IAAIkM,EAAQW,OACpBR,EAAchJ,KAShB,OAAO,WACL2D,GAAO8F,KAAK,iBAEjB,CAACZ,EAAS5I,EAAYyI,EAAOQ,EAAYF,EAAeD,EAAcD,IAIvE,oCACA,sCACA,2BAAK/D,GAEL,2BACM8E,KAAK,OACLpI,MAAOxG,EACP6O,SAAU,SAAAC,GAAC,OAAIX,EAAWW,EAAEC,OAAOvI,UAElC,2BACAoI,KAAO,OACPpI,MACEvG,EAEF4O,SAAa,SAACC,GACZ,IAAI7O,EAEFA,EADmB,IAAlB6O,EAAEC,OAAOvI,MACD,EAEDwI,SAASF,EAAEC,OAAOvI,OAE3B4H,EAAUnO,MAIb,4BAASgP,QAAY,WACnBvD,KACAuC,EAAWpC,MACXnD,GAAO8F,KAAK,iBAAkBrE,QAHhC,sBAMC,4BAAS8E,QACP,WAEEvG,GAAO8F,KAAK,SAAUzC,GAAgB/L,EAASC,MAHnD,qBAQA0F,EAAO8C,SAAS,SAACyG,GACf,OAAQ,yCAKtB,+BAAKlK,EAAL,KACA,+BAAKgJ,EAAL,KACC,mDC5HmBmB,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAAShL,MACvB,2DCZNiL,IAASC,OAAO,kBAAC,GAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,iB,gGErInBC,EAAOC,QAAU,IAA0B,mC","file":"static/js/main.08e3fac6.chunk.js","sourcesContent":["import * as WebSocket from 'ws';\nimport {Server} from 'ws';\n\nimport socket from \"socket.io\"\nimport {\n    addBlockToChain, Block, getBlockchain, getLatestBlock, handleReceivedTransaction, isValidBlockStructure,\n    replaceChain\n} from './blockchain';\nimport {Transaction} from './transaction';\nimport {getTransactionPool} from './transactionPool';\n\nconst sockets: WebSocket[] = [];\n\nenum MessageType {\n    QUERY_LATEST = 0,\n    QUERY_ALL = 1,\n    RESPONSE_BLOCKCHAIN = 2,\n    QUERY_TRANSACTION_POOL = 3,\n    RESPONSE_TRANSACTION_POOL = 4\n}\n\nclass Message {\n    public type: MessageType;\n    public data: any;\n}\n\nconst initP2PServer = (p2pPort: number) => {\n    const server: Server = new WebSocket.Server({port: p2pPort});\n    server.on('connection', (ws: WebSocket) => {\n        initConnection(ws);\n    });\n    console.log('listening websocket p2p port on: ' + p2pPort);\n};\n\nconst getSockets = () => sockets;\n\nconst initConnection = (ws: WebSocket) => {\n    sockets.push(ws);\n    initMessageHandler(ws);\n    initErrorHandler(ws);\n    write(ws, queryChainLengthMsg());\n\n    // query transactions pool only some time after chain query\n    setTimeout(() => {\n        broadcast(queryTransactionPoolMsg());\n    }, 500);\n};\n\nconst JSONToObject = <T>(data: string): T => {\n    try {\n        return JSON.parse(data);\n    } catch (e) {\n        console.log(e);\n        return null;\n    }\n};\n\nconst initMessageHandler = (ws: WebSocket) => {\n    ws.on('message', (data: string) => {\n\n        try {\n            const message: Message = JSONToObject<Message>(data);\n            if (message === null) {\n                console.log('could not parse received JSON message: ' + data);\n                return;\n            }\n            console.log('Received message: %s', JSON.stringify(message));\n            switch (message.type) {\n                case MessageType.QUERY_LATEST:\n                    write(ws, responseLatestMsg());\n                    break;\n                case MessageType.QUERY_ALL:\n                    write(ws, responseChainMsg());\n                    break;\n                case MessageType.RESPONSE_BLOCKCHAIN:\n                    const receivedBlocks: Block[] = JSONToObject<Block[]>(message.data);\n                    if (receivedBlocks === null) {\n                        console.log('invalid blocks received: %s', JSON.stringify(message.data));\n                        break;\n                    }\n                    handleBlockchainResponse(receivedBlocks);\n                    break;\n                case MessageType.QUERY_TRANSACTION_POOL:\n                    write(ws, responseTransactionPoolMsg());\n                    break;\n                case MessageType.RESPONSE_TRANSACTION_POOL:\n                    const receivedTransactions: Transaction[] = JSONToObject<Transaction[]>(message.data);\n                    if (receivedTransactions === null) {\n                        console.log('invalid transaction received: %s', JSON.stringify(message.data));\n                        break;\n                    }\n                    receivedTransactions.forEach((transaction: Transaction) => {\n                        try {\n                            handleReceivedTransaction(transaction);\n                            // if no error is thrown, transaction was indeed added to the pool\n                            // let's broadcast transaction pool\n                            broadCastTransactionPool();\n                        } catch (e) {\n                            console.log(e.message);\n                        }\n                    });\n                    break;\n            }\n        } catch (e) {\n            console.log(e);\n        }\n    });\n};\n\nconst write = (ws: WebSocket, message: Message): void => ws.send(JSON.stringify(message));\nconst broadcast = (message: Message): void => sockets.forEach((socket) => write(socket, message));\n\nconst queryChainLengthMsg = (): Message => ({'type': MessageType.QUERY_LATEST, 'data': null});\n\nconst queryAllMsg = (): Message => ({'type': MessageType.QUERY_ALL, 'data': null});\n\nconst responseChainMsg = (): Message => ({\n    'type': MessageType.RESPONSE_BLOCKCHAIN, 'data': JSON.stringify(getBlockchain())\n});\n\nconst responseLatestMsg = (): Message => ({\n    'type': MessageType.RESPONSE_BLOCKCHAIN,\n    'data': JSON.stringify([getLatestBlock()])\n});\n\nconst queryTransactionPoolMsg = (): Message => ({\n    'type': MessageType.QUERY_TRANSACTION_POOL,\n    'data': null\n});\n\nconst responseTransactionPoolMsg = (): Message => ({\n    'type': MessageType.RESPONSE_TRANSACTION_POOL,\n    'data': JSON.stringify(getTransactionPool())\n});\n\nconst initErrorHandler = (ws: WebSocket) => {\n    const closeConnection = (myWs: WebSocket) => {\n        console.log('connection failed to peer: ' + myWs.url);\n        sockets.splice(sockets.indexOf(myWs), 1);\n    };\n    ws.on('close', () => closeConnection(ws));\n    ws.on('error', () => closeConnection(ws));\n};\n\nconst handleBlockchainResponse = (receivedBlocks: Block[]) => {\n    if (receivedBlocks.length === 0) {\n        console.log('received block chain size of 0');\n        return;\n    }\n    const latestBlockReceived: Block = receivedBlocks[receivedBlocks.length - 1];\n    if (!isValidBlockStructure(latestBlockReceived)) {\n        console.log('block structuture not valid');\n        return;\n    }\n    const latestBlockHeld: Block = getLatestBlock();\n    if (latestBlockReceived.index > latestBlockHeld.index) {\n        console.log('blockchain possibly behind. We got: '\n            + latestBlockHeld.index + ' Peer got: ' + latestBlockReceived.index);\n        if (latestBlockHeld.hash === latestBlockReceived.previousHash) {\n            if (addBlockToChain(latestBlockReceived)) {\n                broadcast(responseLatestMsg());\n            }\n        } else if (receivedBlocks.length === 1) {\n            console.log('We have to query the chain from our peer');\n            broadcast(queryAllMsg());\n        } else {\n            console.log('Received blockchain is longer than current blockchain');\n            replaceChain(receivedBlocks);\n        }\n    } else {\n        console.log('received blockchain is not longer than received blockchain. Do nothing');\n    }\n};\n\nconst broadcastLatest = (): void => {\n    broadcast(responseLatestMsg());\n};\n\nconst connectToPeers = (newPeer: string): void => {\n    const ws: WebSocket = new WebSocket(newPeer);\n    ws.on('open', () => {\n        initConnection(ws);\n    });\n    ws.on('error', () => {\n        console.log('connection failed');\n    });\n};\n\nconst broadCastTransactionPool = () => {\n    broadcast(responseTransactionPoolMsg());\n};\n\nexport {handleBlockchainResponse, connectToPeers, broadcastLatest, broadCastTransactionPool, initP2PServer, getSockets};\n","import * as CryptoJS from 'crypto-js';\nimport * as ecdsa from 'elliptic';\nimport * as _ from 'lodash';\n\nconst ec = new ecdsa.ec('secp256k1');\n\nconst COINBASE_AMOUNT: number = 50;\n\nclass UnspentTxOut {\n    public readonly txOutId: string;\n    public readonly txOutIndex: number;\n    public readonly address: string;\n    public readonly amount: number;\n\n    constructor(txOutId: string, txOutIndex: number, address: string, amount: number) {\n        this.txOutId = txOutId;\n        this.txOutIndex = txOutIndex;\n        this.address = address;\n        this.amount = amount;\n    }\n}\n\nclass TxIn {\n    public txOutId: string;\n    public txOutIndex: number;\n    public signature: string;\n}\n\nclass TxOut {\n    public address: string;\n    public amount: number;\n\n    constructor(address: string, amount: number) {\n        this.address = address;\n        this.amount = amount;\n    }\n}\n\nclass Transaction {\n\n    public id: string;\n\n    public txIns: TxIn[];\n    public txOuts: TxOut[];\n}\n\nconst getTransactionId = (transaction: Transaction): string => {\n    const txInContent: string = transaction.txIns\n        .map((txIn: TxIn) => txIn.txOutId + txIn.txOutIndex)\n        .reduce((a, b) => a + b, '');\n\n    const txOutContent: string = transaction.txOuts\n        .map((txOut: TxOut) => txOut.address + txOut.amount)\n        .reduce((a, b) => a + b, '');\n\n    return CryptoJS.SHA256(txInContent + txOutContent).toString();\n};\n\nconst validateTransaction = (transaction: Transaction, aUnspentTxOuts: UnspentTxOut[]): boolean => {\n\n    if (!isValidTransactionStructure(transaction)) {\n        return false;\n    }\n\n    if (getTransactionId(transaction) !== transaction.id) {\n        console.log('invalid tx id: ' + transaction.id);\n        return false;\n    }\n    const hasValidTxIns: boolean = transaction.txIns\n        .map((txIn) => validateTxIn(txIn, transaction, aUnspentTxOuts))\n        .reduce((a, b) => a && b, true);\n\n    if (!hasValidTxIns) {\n        console.log('some of the txIns are invalid in tx: ' + transaction.id);\n        return false;\n    }\n\n    const totalTxInValues: number = transaction.txIns\n        .map((txIn) => getTxInAmount(txIn, aUnspentTxOuts))\n        .reduce((a, b) => (a + b), 0);\n\n    const totalTxOutValues: number = transaction.txOuts\n        .map((txOut) => txOut.amount)\n        .reduce((a, b) => (a + b), 0);\n\n    if (totalTxOutValues !== totalTxInValues) {\n        console.log('totalTxOutValues !== totalTxInValues in tx: ' + transaction.id);\n        return false;\n    }\n\n    return true;\n};\n\nconst validateBlockTransactions = (aTransactions: Transaction[], aUnspentTxOuts: UnspentTxOut[], blockIndex: number): boolean => {\n    const coinbaseTx = aTransactions[0];\n    if (!validateCoinbaseTx(coinbaseTx, blockIndex)) {\n        console.log('invalid coinbase transaction: ' + JSON.stringify(coinbaseTx));\n        return false;\n    }\n\n    // check for duplicate txIns. Each txIn can be included only once\n    // const txIns: TxIn[] = _(aTransactions)\n    //     .map((tx) => tx.txIns)\n    //     .flatten()\n    //     .value();\n\n    // if (hasDuplicates(txIns)) {\n    //     return false;\n    // }\n\n    // all but coinbase transactions\n    const normalTransactions: Transaction[] = aTransactions.slice(1);\n    return normalTransactions.map((tx) => validateTransaction(tx, aUnspentTxOuts))\n        .reduce((a, b) => (a && b), true);\n\n};\n\nconst hasDuplicates = (txIns: TxIn[]): boolean => {\n    const groups = _.countBy(txIns, (txIn: TxIn) => txIn.txOutId + txIn.txOutIndex);\n    return _(groups)\n        .map((value, key) => {\n            if (value > 1) {\n                console.log('duplicate txIn: ' + key);\n                return true;\n            } else {\n                return false;\n            }\n        })\n        .includes(true);\n};\n\nconst validateCoinbaseTx = (transaction: Transaction, blockIndex: number): boolean => {\n    if (transaction == null) {\n        console.log('the first transaction in the block must be coinbase transaction');\n        return false;\n    }\n    if (getTransactionId(transaction) !== transaction.id) {\n        console.log('invalid coinbase tx id: ' + transaction.id);\n        return false;\n    }\n    if (transaction.txIns.length !== 1) {\n        console.log('one txIn must be specified in the coinbase transaction');\n        return;\n    }\n    if (transaction.txIns[0].txOutIndex !== blockIndex) {\n        console.log('the txIn signature in coinbase tx must be the block height');\n        return false;\n    }\n    if (transaction.txOuts.length !== 1) {\n        console.log('invalid number of txOuts in coinbase transaction');\n        return false;\n    }\n    if (transaction.txOuts[0].amount !== COINBASE_AMOUNT) {\n        console.log('invalid coinbase amount in coinbase transaction');\n        return false;\n    }\n    return true;\n};\n\nconst validateTxIn = (txIn: TxIn, transaction: Transaction, aUnspentTxOuts: UnspentTxOut[]): boolean => {\n    const referencedUTxOut: UnspentTxOut =\n        aUnspentTxOuts.find((uTxO) => uTxO.txOutId === txIn.txOutId && uTxO.txOutIndex === txIn.txOutIndex);\n    if (referencedUTxOut == null) {\n        console.log('referenced txOut not found: ' + JSON.stringify(txIn));\n        return false;\n    }\n    const address = referencedUTxOut.address;\n\n    const key = ec.keyFromPublic(address, 'hex');\n    const validSignature: boolean = key.verify(transaction.id, txIn.signature);\n    if (!validSignature) {\n        console.log('invalid txIn signature: %s txId: %s address: %s', txIn.signature, transaction.id, referencedUTxOut.address);\n        return false;\n    }\n    return true;\n};\n\nconst getTxInAmount = (txIn: TxIn, aUnspentTxOuts: UnspentTxOut[]): number => {\n    return findUnspentTxOut(txIn.txOutId, txIn.txOutIndex, aUnspentTxOuts).amount;\n};\n\nconst findUnspentTxOut = (transactionId: string, index: number, aUnspentTxOuts: UnspentTxOut[]): UnspentTxOut => {\n    return aUnspentTxOuts.find((uTxO) => uTxO.txOutId === transactionId && uTxO.txOutIndex === index);\n};\n\nconst getCoinbaseTransaction = (address: string, blockIndex: number): Transaction => {\n    const t = new Transaction();\n    const txIn: TxIn = new TxIn();\n    txIn.signature = '';\n    txIn.txOutId = '';\n    txIn.txOutIndex = blockIndex;\n\n    t.txIns = [txIn];\n    t.txOuts = [new TxOut(address, COINBASE_AMOUNT)];\n    t.id = getTransactionId(t);\n    return t;\n};\n\nconst signTxIn = (transaction: Transaction, txInIndex: number,\n                  privateKey: string, aUnspentTxOuts: UnspentTxOut[]): string => {\n    const txIn: TxIn = transaction.txIns[txInIndex];\n\n    const dataToSign = transaction.id;\n    const referencedUnspentTxOut: UnspentTxOut = findUnspentTxOut(txIn.txOutId, txIn.txOutIndex, aUnspentTxOuts);\n    if (referencedUnspentTxOut == null) {\n        console.log('could not find referenced txOut');\n        throw Error();\n    }\n    const referencedAddress = referencedUnspentTxOut.address;\n\n    if (getPublicKey(privateKey) !== referencedAddress) {\n        console.log('trying to sign an input with private' +\n            ' key that does not match the address that is referenced in txIn');\n        throw Error();\n    }\n    const key = ec.keyFromPrivate(privateKey, 'hex');\n    const signature: string = toHexString(key.sign(dataToSign).toDER());\n\n    return signature;\n};\n\nconst updateUnspentTxOuts = (aTransactions: Transaction[], aUnspentTxOuts: UnspentTxOut[]): UnspentTxOut[] => {\n    const newUnspentTxOuts: UnspentTxOut[] = aTransactions\n        .map((t) => {\n            return t.txOuts.map((txOut, index) => new UnspentTxOut(t.id, index, txOut.address, txOut.amount));\n        })\n        .reduce((a, b) => a.concat(b), []);\n\n    const consumedTxOuts: UnspentTxOut[] = aTransactions\n        .map((t) => t.txIns)\n        .reduce((a, b) => a.concat(b), [])\n        .map((txIn) => new UnspentTxOut(txIn.txOutId, txIn.txOutIndex, '', 0));\n\n    const resultingUnspentTxOuts = aUnspentTxOuts\n        .filter(((uTxO) => !findUnspentTxOut(uTxO.txOutId, uTxO.txOutIndex, consumedTxOuts)))\n        .concat(newUnspentTxOuts);\n\n    return resultingUnspentTxOuts;\n};\n\nconst processTransactions = (aTransactions: Transaction[], aUnspentTxOuts: UnspentTxOut[], blockIndex: number) => {\n\n    if (!validateBlockTransactions(aTransactions, aUnspentTxOuts, blockIndex)) {\n        console.log('invalid block transactions');\n        return null;\n    }\n    return updateUnspentTxOuts(aTransactions, aUnspentTxOuts);\n};\n\nconst toHexString = (byteArray): string => {\n    return Array.from(byteArray, (byte: any) => {\n        return ('0' + (byte & 0xFF).toString(16)).slice(-2);\n    }).join('');\n};\n\nconst getPublicKey = (aPrivateKey: string): string => {\n    return ec.keyFromPrivate(aPrivateKey, 'hex').getPublic().encode('hex');\n};\n\nconst isValidTxInStructure = (txIn: TxIn): boolean => {\n    if (txIn == null) {\n        console.log('txIn is null');\n        return false;\n    } else if (typeof txIn.signature !== 'string') {\n        console.log('invalid signature type in txIn');\n        return false;\n    } else if (typeof txIn.txOutId !== 'string') {\n        console.log('invalid txOutId type in txIn');\n        return false;\n    } else if (typeof  txIn.txOutIndex !== 'number') {\n        console.log('invalid txOutIndex type in txIn');\n        return false;\n    } else {\n        return true;\n    }\n};\n\nconst isValidTxOutStructure = (txOut: TxOut): boolean => {\n    if (txOut == null) {\n        console.log('txOut is null');\n        return false;\n    } else if (typeof txOut.address !== 'string') {\n        console.log('invalid address type in txOut');\n        return false;\n    } else if (!isValidAddress(txOut.address)) {\n        console.log('invalid TxOut address');\n        return false;\n    } else if (typeof txOut.amount !== 'number') {\n        console.log('invalid amount type in txOut');\n        return false;\n    } else {\n        return true;\n    }\n};\n\nconst isValidTransactionStructure = (transaction: Transaction) => {\n    if (typeof transaction.id !== 'string') {\n        console.log('transactionId missing');\n        return false;\n    }\n    if (!(transaction.txIns instanceof Array)) {\n        console.log('invalid txIns type in transaction');\n        return false;\n    }\n    if (!transaction.txIns\n            .map(isValidTxInStructure)\n            .reduce((a, b) => (a && b), true)) {\n        return false;\n    }\n\n    if (!(transaction.txOuts instanceof Array)) {\n        console.log('invalid txIns type in transaction');\n        return false;\n    }\n\n    if (!transaction.txOuts\n            .map(isValidTxOutStructure)\n            .reduce((a, b) => (a && b), true)) {\n        return false;\n    }\n    return true;\n};\n\n// valid address is a valid ecdsa public key in the 04 + X-coordinate + Y-coordinate format\nconst isValidAddress = (address: string): boolean => {\n    if (address.length !== 130) {\n        console.log(address);\n        console.log('invalid public key length');\n        return true;\n    } else if (address.match('^[a-fA-F0-9]+$') === null) {\n        console.log('public key must contain only hex characters');\n        return false;\n    } else if (!address.startsWith('04')) {\n        console.log('public key must start with 04');\n        return false;\n    }\n    return true;\n};\n\nexport {\n    processTransactions, signTxIn, getTransactionId, isValidAddress, validateTransaction,\n    UnspentTxOut, TxIn, TxOut, getCoinbaseTransaction, getPublicKey, hasDuplicates,\n    Transaction\n};\n","import {ec} from 'elliptic';\nimport {existsSync, readFileSync, unlinkSync, writeFileSync} from 'fs';\nimport * as _ from 'lodash';\nimport {getPublicKey, getTransactionId, signTxIn, Transaction, TxIn, TxOut, UnspentTxOut} from './transaction';\nimport { useCookies } from \"react-cookie\";\nimport Cookies from \"js-cookie\";\nconst EC = new ec('secp256k1');\nconst privateKeyLocation = process.env.PRIVATE_KEY || 'node/wallet/private_key';\nconst getPrivateFromWallet = (): string => {\n   // const buffer = readFileSync(privateKeyLocation, 'utf8');\n   let cookie = Cookies.get(\"jerry\");\n   console.log(cookie);\n   return cookie; //buffer.toString();\n};\n\nconst getPublicFromWallet = (): string => {\n    const privateKey = getPrivateFromWallet();\n    const key = EC.keyFromPrivate(privateKey, 'hex');\n    console.log(key.getPublic())\n    return key.getPublic().encode('hex');\n};\n\nconst generatePrivateKey = (): string => {\n  \n    const keyPair = EC.genKeyPair();\n    const privateKey = keyPair.getPrivate();\n    return privateKey.toString(16);;\n};\n\nconst initWallet = () => {\n    // let's not override existing private keys\n   // if (existsSync(privateKeyLocation)) {\n\n//    if(cookies.jerry != \"\")  {\n//    return;\n//     }\n//     const newPrivateKey = generatePrivateKey();\n\n//     //writeFileSync(privateKeyLocation, newPrivateKey);\n//     setCookie('jerry', newPrivateKey);\n   // console.log('new wallet with private key created to : %s', privateKeyLocation);\n};\n\nconst deleteWallet = () => {\n    if (existsSync(privateKeyLocation)) {\n        unlinkSync(privateKeyLocation);\n    }\n};\n\nconst getBalance = (address: string, unspentTxOuts: UnspentTxOut[]): number => {\n    return _(findUnspentTxOuts(address, unspentTxOuts))\n        .map((uTxO: UnspentTxOut) => uTxO.amount)\n        .sum();\n};\n\nconst findUnspentTxOuts = (ownerAddress: string, unspentTxOuts: UnspentTxOut[]) => {\n    return _.filter(unspentTxOuts, (uTxO: UnspentTxOut) => uTxO.address === ownerAddress);\n};\n\nconst findTxOutsForAmount = (amount: number, myUnspentTxOuts: UnspentTxOut[]) => {\n    let currentAmount = 0;\n    const includedUnspentTxOuts = [];\n    for (const myUnspentTxOut of myUnspentTxOuts) {\n        includedUnspentTxOuts.push(myUnspentTxOut);\n        currentAmount = currentAmount + myUnspentTxOut.amount;\n        if (currentAmount >= amount) {\n            const leftOverAmount = currentAmount - amount;\n            return {includedUnspentTxOuts, leftOverAmount};\n        }\n    }\n\n    const eMsg = 'Cannot create transaction from the available unspent transaction outputs.' +\n        ' Required amount:' + amount + '. Available unspentTxOuts:' + JSON.stringify(myUnspentTxOuts);\n    throw Error(eMsg);\n};\n\nconst createTxOuts = (receiverAddress: string, myAddress: string, amount, leftOverAmount: number) => {\n    const txOut1: TxOut = new TxOut(receiverAddress, amount);\n    if (leftOverAmount === 0) {\n        return [txOut1];\n    } else {\n        const leftOverTx = new TxOut(myAddress, leftOverAmount);\n        return [txOut1, leftOverTx];\n    }\n};\n\nconst filterTxPoolTxs = (unspentTxOuts: UnspentTxOut[], transactionPool: Transaction[]): UnspentTxOut[] => {\n    const txIns: TxIn[] = _(transactionPool)\n        .map((tx: Transaction) => tx.txIns)\n        .flatten()\n        .value();\n    const removable: UnspentTxOut[] = [];\n    for (const unspentTxOut of unspentTxOuts) {\n        const txIn = _.find(txIns, (aTxIn: TxIn) => {\n            return aTxIn.txOutIndex === unspentTxOut.txOutIndex && aTxIn.txOutId === unspentTxOut.txOutId;\n        });\n\n        if (txIn === undefined) {\n\n        } else {\n            removable.push(unspentTxOut);\n        }\n    }\n\n    return _.without(unspentTxOuts, ...removable);\n};\n\nconst createTransaction = (receiverAddress: string, amount: number, privateKey: string,\n                           unspentTxOuts: UnspentTxOut[], txPool: Transaction[]): Transaction => {\n\n    console.log('txPool: %s', JSON.stringify(txPool));\n    const myAddress: string = getPublicKey(privateKey);\n    const myUnspentTxOutsA = unspentTxOuts.filter((uTxO: UnspentTxOut) => uTxO.address === myAddress);\n\n    const myUnspentTxOuts = filterTxPoolTxs(myUnspentTxOutsA, txPool);\n\n    // filter from unspentOutputs such inputs that are referenced in pool\n    const {includedUnspentTxOuts, leftOverAmount} = findTxOutsForAmount(amount, myUnspentTxOuts);\n\n    const toUnsignedTxIn = (unspentTxOut: UnspentTxOut) => {\n        const txIn: TxIn = new TxIn();\n        txIn.txOutId = unspentTxOut.txOutId;\n        txIn.txOutIndex = unspentTxOut.txOutIndex;\n        return txIn;\n    };\n\n    const unsignedTxIns: TxIn[] = includedUnspentTxOuts.map(toUnsignedTxIn);\n\n    const tx: Transaction = new Transaction();\n    tx.txIns = unsignedTxIns;\n    tx.txOuts = createTxOuts(receiverAddress, myAddress, amount, leftOverAmount);\n    tx.id = getTransactionId(tx);\n\n    tx.txIns = tx.txIns.map((txIn: TxIn, index: number) => {\n        txIn.signature = signTxIn(tx, index, privateKey, unspentTxOuts);\n        return txIn;\n    });\n\n    return tx;\n};\n\nexport {createTransaction, getPublicFromWallet,\n    getPrivateFromWallet, getBalance, generatePrivateKey, initWallet, deleteWallet, findUnspentTxOuts};\n","import * as _ from 'lodash';\nimport {Transaction, TxIn, UnspentTxOut, validateTransaction} from './transaction';\n\nlet transactionPool: Transaction[] = [];\n\nconst getTransactionPool = () => {\n    return _.cloneDeep(transactionPool);\n};\n\nconst setTransactionPool = ( txPool: Transaction[]) => {\n    transactionPool = txPool;\n}\n\nconst addToTransactionPool = (tx: Transaction, unspentTxOuts: UnspentTxOut[]) => {\n\n    if (!validateTransaction(tx, unspentTxOuts)) {\n        throw Error('Trying to add invalid tx to pool');\n    }\n\n    if (!isValidTxForPool(tx, transactionPool)) {\n        throw Error('Trying to add invalid tx to pool');\n    }\n    console.log('adding to txPool: %s', JSON.stringify(tx));\n    transactionPool.push(tx);\n};\n\nconst hasTxIn = (txIn: TxIn, unspentTxOuts: UnspentTxOut[]): boolean => {\n    const foundTxIn = unspentTxOuts.find((uTxO: UnspentTxOut) => {\n        return uTxO.txOutId === txIn.txOutId && uTxO.txOutIndex === txIn.txOutIndex;\n    });\n    return foundTxIn !== undefined;\n};\n\nconst updateTransactionPool = (unspentTxOuts: UnspentTxOut[]) => {\n    const invalidTxs = [];\n    for (const tx of transactionPool) {\n        for (const txIn of tx.txIns) {\n            if (!hasTxIn(txIn, unspentTxOuts)) {\n                invalidTxs.push(tx);\n                break;\n            }\n        }\n    }\n    if (invalidTxs.length > 0) {\n        console.log('removing the following transactions from txPool: %s', JSON.stringify(invalidTxs));\n        transactionPool = _.without(transactionPool, ...invalidTxs);\n    }\n};\n\nconst getTxPoolIns = (aTransactionPool: Transaction[]): TxIn[] => {\n    return _(aTransactionPool)\n        .map((tx) => tx.txIns)\n        .flatten()\n        .value();\n};\n\nconst isValidTxForPool = (tx: Transaction, aTtransactionPool: Transaction[]): boolean => {\n    const txPoolIns: TxIn[] = getTxPoolIns(aTtransactionPool);\n\n    const containsTxIn = (txIns: TxIn[], txIn: TxIn) => {\n        return _.find(txPoolIns, ((txPoolIn) => {\n            return txIn.txOutIndex === txPoolIn.txOutIndex && txIn.txOutId === txPoolIn.txOutId;\n        }));\n    };\n\n    for (const txIn of tx.txIns) {\n        if (containsTxIn(txPoolIns, txIn)) {\n            console.log('txIn already found in the txPool');\n            return false;\n        }\n    }\n    return true;\n};\n\nexport {setTransactionPool, addToTransactionPool, getTransactionPool, updateTransactionPool};\n","import * as CryptoJS from 'crypto-js';\nimport * as _ from 'lodash';\nimport {broadcastLatest, broadCastTransactionPool} from './p2p';\nimport {\n    getCoinbaseTransaction, isValidAddress, processTransactions, Transaction, UnspentTxOut\n} from './transaction';\nimport {addToTransactionPool, getTransactionPool, updateTransactionPool} from './transactionPool';\nimport {hexToBinary} from './util';\nimport {createTransaction, findUnspentTxOuts, getBalance, getPrivateFromWallet, getPublicFromWallet} from './wallet';\n\nclass Block {\n\n    public index: number;\n    public hash: string;\n    public previousHash: string;\n    public timestamp: number;\n    public data: Transaction[];\n    public difficulty: number;\n    public nonce: number;\n\n    constructor(index: number, hash: string, previousHash: string,\n                timestamp: number, data: Transaction[], difficulty: number, nonce: number) {\n        this.index = index;\n        this.previousHash = previousHash;\n        this.timestamp = timestamp;\n        this.data = data;\n        this.hash = hash;\n        this.difficulty = difficulty;\n        this.nonce = nonce;\n    }\n}\n\nconst genesisTransaction = {\n    'txIns': [{'signature': '', 'txOutId': '', 'txOutIndex': 0}],\n    'txOuts': [{\n        'address': '04bfcab8722991ae774db48f934ca79cfb7dd991229153b9f732ba5334aafcd8e7266e47076996b55a14bf9913ee3145ce0cfc1372ada8ada74bd287450313534a',\n        'amount': 50\n    }],\n    'id': 'e655f6a5f26dc9b4cac6e46f52336428287759cf81ef5ff10854f69d68f43fa3'\n};\n\nconst genesisBlock: Block = new Block(\n    0, '91a73664bc84c0baa1fc75ea6e4aa6d1d20c5df664c724e3159aefc2e1186627', '', 1465154705, [genesisTransaction], 0, 0\n);\n\nlet blockchain: Block[] = [genesisBlock];\n\n// the unspent txOut of genesis block is set to unspentTxOuts on startup\nlet unspentTxOuts: UnspentTxOut[] = processTransactions(blockchain[0].data, [], 0);\n\nconst getBlockchain = (): Block[] => blockchain;\n\nconst setBlockchain = (bc: Block[]) => {\n  blockchain = bc;\n  unspentTxOuts = isValidChain(blockchain);\n};\n\nconst getUnspentTxOuts = (): UnspentTxOut[] => _.cloneDeep(unspentTxOuts);\n\n// and txPool should be only updated at the same time\nconst setUnspentTxOuts = (newUnspentTxOut: UnspentTxOut[]) => {\n    console.log('replacing unspentTxouts with: %s', newUnspentTxOut);\n    unspentTxOuts = newUnspentTxOut;\n};\n\nconst getLatestBlock = (): Block => blockchain[blockchain.length - 1];\n\n// in seconds\nconst BLOCK_GENERATION_INTERVAL: number = 10;\n\n// in blocks\nconst DIFFICULTY_ADJUSTMENT_INTERVAL: number = 10;\n\nconst getDifficulty = (aBlockchain: Block[]): number => {\n    const latestBlock: Block = aBlockchain[blockchain.length - 1];\n    if (latestBlock.index % DIFFICULTY_ADJUSTMENT_INTERVAL === 0 && latestBlock.index !== 0) {\n        return getAdjustedDifficulty(latestBlock, aBlockchain);\n    } else {\n        return latestBlock.difficulty;\n    }\n};\n\nconst getAdjustedDifficulty = (latestBlock: Block, aBlockchain: Block[]) => {\n    const prevAdjustmentBlock: Block = aBlockchain[blockchain.length - DIFFICULTY_ADJUSTMENT_INTERVAL];\n    const timeExpected: number = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;\n    const timeTaken: number = latestBlock.timestamp - prevAdjustmentBlock.timestamp;\n    if (timeTaken < timeExpected / 2) {\n        return prevAdjustmentBlock.difficulty + 1;\n    } else if (timeTaken > timeExpected * 2) {\n        return prevAdjustmentBlock.difficulty - 1;\n    } else {\n        return prevAdjustmentBlock.difficulty;\n    }\n};\n\nconst getCurrentTimestamp = (): number => Math.round(new Date().getTime() / 1000);\n\nconst generateRawNextBlock = (blockData: Transaction[]) => {\n    const previousBlock: Block = getLatestBlock();\n    const difficulty: number = getDifficulty(getBlockchain());\n    const nextIndex: number = previousBlock.index + 1;\n    const nextTimestamp: number = getCurrentTimestamp();\n    const newBlock: Block = findBlock(nextIndex, previousBlock.hash, nextTimestamp, blockData, difficulty);\n    if (addBlockToChain(newBlock)) {\n        broadcastLatest();\n        return newBlock;\n    } else {\n        return null;\n    }\n\n};\n\n// gets the unspent transaction outputs owned by the wallet\nconst getMyUnspentTransactionOutputs = () => {\n    return findUnspentTxOuts(getPublicFromWallet(), getUnspentTxOuts());\n};\n\nconst generateNextBlock = () => {\n    const coinbaseTx: Transaction = getCoinbaseTransaction(getPublicFromWallet(), getLatestBlock().index + 1);\n    const blockData: Transaction[] = [coinbaseTx].concat(getTransactionPool());\n    return generateRawNextBlock(blockData);\n};\n\nconst generatenextBlockWithTransaction = (receiverAddress: string, amount: number) => {\n    if (!isValidAddress(receiverAddress)) {\n        throw Error('invalid address');\n    }\n    if (typeof amount !== 'number') {\n        throw Error('invalid amount');\n    }\n    const coinbaseTx: Transaction = getCoinbaseTransaction(getPublicFromWallet(), getLatestBlock().index + 1);\n    const tx: Transaction = createTransaction(receiverAddress, amount, getPrivateFromWallet(), getUnspentTxOuts(), getTransactionPool());\n    const blockData: Transaction[] = [coinbaseTx, tx];\n    return generateRawNextBlock(blockData);\n};\n\nconst findBlock = (index: number, previousHash: string, timestamp: number, data: Transaction[], difficulty: number): Block => {\n    let nonce = 0;\n    while (true) {\n        const hash: string = calculateHash(index, previousHash, timestamp, data, difficulty, nonce);\n        if (hashMatchesDifficulty(hash, difficulty)) {\n            return new Block(index, hash, previousHash, timestamp, data, difficulty, nonce);\n        }\n        nonce++;\n    }\n};\n\nconst getAccountBalance = (): number => {\n    return getBalance(getPublicFromWallet(), getUnspentTxOuts());\n};\n\nconst sendTransaction = (address: string, amount: number): Transaction => {\n    const tx: Transaction = createTransaction(address, amount, getPrivateFromWallet(), getUnspentTxOuts(), getTransactionPool());\n    addToTransactionPool(tx, getUnspentTxOuts());\n    broadCastTransactionPool();\n    return tx;\n};\n\nconst calculateHashForBlock = (block: Block): string =>\n    calculateHash(block.index, block.previousHash, block.timestamp, block.data, block.difficulty, block.nonce);\n\nconst calculateHash = (index: number, previousHash: string, timestamp: number, data: Transaction[],\n                       difficulty: number, nonce: number): string =>\n    CryptoJS.SHA256(index + previousHash + timestamp + data + difficulty + nonce).toString();\n\nconst isValidBlockStructure = (block: Block): boolean => {\n    return typeof block.index === 'number'\n        && typeof block.hash === 'string'\n        && typeof block.previousHash === 'string'\n        && typeof block.timestamp === 'number'\n        && typeof block.data === 'object';\n};\n\nconst isValidNewBlock = (newBlock: Block, previousBlock: Block): boolean => {\n    if (!isValidBlockStructure(newBlock)) {\n        console.log('invalid block structure: %s', JSON.stringify(newBlock));\n        return false;\n    }\n    if (previousBlock.index + 1 !== newBlock.index) {\n        console.log('invalid index');\n        return false;\n    } else if (previousBlock.hash !== newBlock.previousHash) {\n        console.log('invalid previoushash');\n        return false;\n    } else if (!isValidTimestamp(newBlock, previousBlock)) {\n        console.log('invalid timestamp');\n        return false;\n    } else if (!hasValidHash(newBlock)) {\n        return false;\n    }\n    return true;\n};\n\nconst getAccumulatedDifficulty = (aBlockchain: Block[]): number => {\n    return aBlockchain\n        .map((block) => block.difficulty)\n        .map((difficulty) => Math.pow(2, difficulty))\n        .reduce((a, b) => a + b);\n};\n\nconst isValidTimestamp = (newBlock: Block, previousBlock: Block): boolean => {\n    return ( previousBlock.timestamp - 60 < newBlock.timestamp )\n        && newBlock.timestamp - 60 < getCurrentTimestamp();\n};\n\nconst hasValidHash = (block: Block): boolean => {\n\n    if (!hashMatchesBlockContent(block)) {\n        console.log('invalid hash, got:' + block.hash);\n        return false;\n    }\n\n    if (!hashMatchesDifficulty(block.hash, block.difficulty)) {\n        console.log('block difficulty not satisfied. Expected: ' + block.difficulty + 'got: ' + block.hash);\n    }\n    return true;\n};\n\nconst hashMatchesBlockContent = (block: Block): boolean => {\n    const blockHash: string = calculateHashForBlock(block);\n    return blockHash === block.hash;\n};\n\nconst hashMatchesDifficulty = (hash: string, difficulty: number): boolean => {\n    const hashInBinary: string = hexToBinary(hash);\n    const requiredPrefix: string = '0'.repeat(difficulty);\n    return hashInBinary.startsWith(requiredPrefix);\n};\n\n/*\n    Checks if the given blockchain is valid. Return the unspent txOuts if the chain is valid\n */\nconst isValidChain = (blockchainToValidate: Block[]): UnspentTxOut[] => {\n    console.log('isValidChain:');\n    console.log(JSON.stringify(blockchainToValidate));\n    const isValidGenesis = (block: Block): boolean => {\n        return JSON.stringify(block) === JSON.stringify(genesisBlock);\n    };\n\n    if (!isValidGenesis(blockchainToValidate[0])) {\n        return null;\n    }\n    /*\n    Validate each block in the chain. The block is valid if the block structure is valid\n      and the transaction are valid\n     */\n    let aUnspentTxOuts: UnspentTxOut[] = [];\n\n    for (let i = 0; i < blockchainToValidate.length; i++) {\n        const currentBlock: Block = blockchainToValidate[i];\n        if (i !== 0 && !isValidNewBlock(blockchainToValidate[i], blockchainToValidate[i - 1])) {\n            return null;\n        }\n\n        aUnspentTxOuts = processTransactions(currentBlock.data, aUnspentTxOuts, currentBlock.index);\n        if (aUnspentTxOuts === null) {\n            console.log('invalid transactions in blockchain');\n            return null;\n        }\n    }\n    return aUnspentTxOuts;\n};\n\nconst addBlockToChain = (newBlock: Block): boolean => {\n    if (isValidNewBlock(newBlock, getLatestBlock())) {\n        const retVal: UnspentTxOut[] = processTransactions(newBlock.data, getUnspentTxOuts(), newBlock.index);\n        if (retVal === null) {\n            console.log('block is not valid in terms of transactions');\n            return false;\n        } else {\n            blockchain.push(newBlock);\n            setUnspentTxOuts(retVal);\n            updateTransactionPool(unspentTxOuts);\n            return true;\n        }\n    }\n    return false;\n};\n\nconst replaceChain = (newBlocks: Block[]) => {\n    const aUnspentTxOuts = isValidChain(newBlocks);\n    const validChain: boolean = aUnspentTxOuts !== null;\n    if (validChain &&\n        getAccumulatedDifficulty(newBlocks) > getAccumulatedDifficulty(getBlockchain())) {\n        console.log('Received blockchain is valid. Replacing current blockchain with received blockchain');\n        blockchain = newBlocks;\n        setUnspentTxOuts(aUnspentTxOuts);\n        updateTransactionPool(unspentTxOuts);\n        broadcastLatest();\n    } else {\n        console.log('Received blockchain invalid');\n    }\n};\n\nconst handleReceivedTransaction = (transaction: Transaction) => {\n    addToTransactionPool(transaction, getUnspentTxOuts());\n};\n\nexport { setBlockchain,\n    Block, getBlockchain, getUnspentTxOuts, getLatestBlock, sendTransaction,\n    generateRawNextBlock, generateNextBlock, generatenextBlockWithTransaction,\n    handleReceivedTransaction, getMyUnspentTransactionOutputs,\n    getAccountBalance, isValidBlockStructure, replaceChain, addBlockToChain\n};\n","const hexToBinary = (s: string): string => {\n    let ret: string = '';\n    const lookupTable = {\n        '0': '0000', '1': '0001', '2': '0010', '3': '0011', '4': '0100',\n        '5': '0101', '6': '0110', '7': '0111', '8': '1000', '9': '1001',\n        'a': '1010', 'b': '1011', 'c': '1100', 'd': '1101',\n        'e': '1110', 'f': '1111'\n    };\n    for (let i: number = 0; i < s.length; i = i + 1) {\n        if (lookupTable[s[i]]) {\n            ret += lookupTable[s[i]];\n        } else {\n            return null;\n        }\n    }\n    return ret;\n};\n\nexport {hexToBinary};\n","import React, {useState, useEffect} from 'react';\nimport io from 'socket.io-client';\nimport logo from './logo.svg';\nimport './App.css';\nimport {generatePrivateKey, getPublicFromWallet} from './crypto/wallet';\nimport {sendTransaction, generateNextBlock, getAccountBalance, getBlockchain, setBlockchain, replaceChain} from \"./crypto/blockchain\"\nimport { useCookies } from 'react-cookie';\nimport { getTransactionPool, setTransactionPool } from \"./crypto/transactionPool\"\nimport {\n  handleBlockchainResponse\n} from \"./crypto/p2p\";\n    const socket = io('http://jerry-server.herokuapp.com', {\n      transports: ['websocket']\n    });\nfunction App() {\n\n    const [data, setData] = useState(0);\n    const [first, setFirst] = useState(true);\n    const [cookies, setCookie, removeCookie] = useCookies(['jerry']);\n    const [privateKey, setPrivateKey] = useState(\"\");\n    const [balance, setBalance] = useState();// useState(getAccountBalance());\n    const [txPool, setTxPool] = useState(getTransactionPool());\n    const [address, setAddress] = useState(\"\");\n    const [amount, setAmount] = useState(0);\n    const [bc, setBc] = useState(getBlockchain());\n\n  // Similar to componentDidMount and componentDidUpdate:\n  useEffect(() => {\n        console.log(\"yeah\", cookies.jerry)\n\n        //Very simply connect to the socket\n        //Listen for data on the \"outgoing data\" namespace and supply a callback for what to do when we get one. In this case, we set a state variable\n        if (first)  {\n          console.log(\"running first\");\n          socket.emit(\"getTxPool\");\n          socket.emit(\"getBlockchain\");\n          setFirst(false);\n        }\n        socket.on(\"resTxPool\", (TxPool) => {\n            console.log(\"got pool:\", TxPool);\n            setTransactionPool(TxPool);\n            setTxPool(TxPool);\n        })\n        socket.on(\"resBlockchain\", (bc) => {\n          console.log(\"got bc:\", bc);\n          if(bc.length > 0) {\nhandleBlockchainResponse(bc)\n setBc(bc);\n          }\n        })\n\n              socket.on(\"tx\", (TxPool) => {\n                console.log(\"got pool:\", TxPool);\n                setTransactionPool(TxPool);\n                setTxPool(TxPool);\n              })\n              socket.on(\"bc\", (bc) => {\n                console.log(\"got bc:\", bc);\n                if (bc.length > 0) {\n                  handleBlockchainResponse(bc);\n                  setBc(bc);\n                }\n              })\n\n\n        if(cookies.jerry == undefined) {\n          let key = generatePrivateKey();\n                    console.log(\"making key\", key)\n                    setCookie(\"jerry\", key);\n\n          setPrivateKey(getPublicFromWallet());\n        } else {\n          console.log(cookies.jerry);\n          setPrivateKey(getPublicFromWallet());\n        }\n\n            //  const newBlock = generateNextBlock();\n\n            //  sendTransaction(generatePrivateKey(), 2);\n            //  setTxPool(getTransactionPool());\n            //  console.log(getTransactionPool());\n            //  setBalance(getAccountBalance());\n        return () => {\n          socket.emit(\"disconnect\");\n        }\n  }, [cookies, privateKey, first, setBalance, setPrivateKey, removeCookie, setCookie]);\n\n\n  return (\n    <>\n    <h1> Test </h1>\n    <p>{ data }</p>\n\n    <input\n          type=\"text\"\n          value={address}\n          onChange={e => setAddress(e.target.value)}\n        />\n           < input\n           type = \"text\"\n           value = {\n             amount\n           }\n           onChange = { (e) => {\n             let amount;\n             if(e.target.value == \"\") {\n               amount = 0;\n             } else {\n              amount = parseInt(e.target.value);\n             }\n              setAmount(amount)\n           }}\n           />\n\n           < button onClick = { () => {\n             generateNextBlock();\n             setBalance(getAccountBalance());\n             socket.emit(\"sendBlockchain\", getBlockchain());\n            } } >generateNextBlock </button>\n\n            < button onClick = {\n              () => {\n                \n                socket.emit(\"sendTx\", sendTransaction(address, amount));\n              }\n            } > sendTransaction </button>\n           \n\n           {txPool.forEach( (item) => {\n              return (<p>item.id</p>);\n           }\n             \n           ) }\n\n<p> {privateKey} </p>\n<p> {balance} </p>\n <p> transactionPool: </p> \n\n \n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";"],"sourceRoot":""}