{"version":3,"sources":["assets/ultimateJerry.gif","crypto/transaction.ts","crypto/wallet.ts","crypto/transactionPool.ts","crypto/blockchain.ts","crypto/util.ts","crypto/p2p.ts","App.js","views/IndexSections/Hero.jsx","views/Index.jsx","index.js"],"names":["module","exports","ec","ecdsa","UnspentTxOut","txOutId","txOutIndex","address","amount","this","TxIn","signature","TxOut","Transaction","id","txIns","txOuts","getTransactionId","transaction","txInContent","map","txIn","reduce","a","b","txOutContent","txOut","CryptoJS","toString","validateTransaction","aUnspentTxOuts","isValidTransactionStructure","console","log","validateTxIn","totalTxInValues","getTxInAmount","validateCoinbaseTx","blockIndex","length","referencedUTxOut","find","uTxO","JSON","stringify","keyFromPublic","verify","findUnspentTxOut","transactionId","index","getCoinbaseTransaction","t","processTransactions","aTransactions","coinbaseTx","slice","tx","validateBlockTransactions","newUnspentTxOuts","concat","consumedTxOuts","filter","updateUnspentTxOuts","toHexString","byteArray","Array","from","byte","join","getPublicKey","aPrivateKey","keyFromPrivate","getPublic","encode","isValidTxInStructure","isValidTxOutStructure","isValidAddress","match","startsWith","EC","getPrivateFromWallet","cookie","Cookies","get","getPublicFromWallet","privateKey","key","generatePrivateKey","genKeyPair","getPrivate","findUnspentTxOuts","ownerAddress","unspentTxOuts","_","createTransaction","receiverAddress","txPool","myAddress","myUnspentTxOuts","currentAmount","includedUnspentTxOuts","myUnspentTxOut","push","leftOverAmount","eMsg","Error","findTxOutsForAmount","transactionPool","flatten","value","removable","unspentTxOut","undefined","aTxIn","filterTxPoolTxs","unsignedTxIns","txOut1","createTxOuts","txInIndex","dataToSign","referencedUnspentTxOut","referencedAddress","sign","toDER","signTxIn","getTransactionPool","setTransactionPool","addToTransactionPool","isValidTxForPool","hasTxIn","updateTransactionPool","invalidTxs","aTtransactionPool","txPoolIns","containsTxIn","txPoolIn","Block","hash","previousHash","timestamp","data","difficulty","nonce","genesisBlock","blockchain","getBlockchain","getUnspentTxOuts","setUnspentTxOuts","newUnspentTxOut","getLatestBlock","getAdjustedDifficulty","latestBlock","aBlockchain","prevAdjustmentBlock","timeTaken","timeExpected","getCurrentTimestamp","Math","round","Date","getTime","generateRawNextBlock","blockData","previousBlock","getDifficulty","nextIndex","nextTimestamp","newBlock","findBlock","addBlockToChain","generateNextBlock","calculateHash","hashMatchesDifficulty","getAccountBalance","sum","sendTransaction","isValidBlockStructure","block","isValidNewBlock","isValidTimestamp","hasValidHash","getAccumulatedDifficulty","pow","hashMatchesBlockContent","calculateHashForBlock","hashInBinary","s","ret","lookupTable","i","hexToBinary","requiredPrefix","repeat","isValidChain","blockchainToValidate","currentBlock","retVal","handleBlockchainResponse","receivedBlocks","latestBlockReceived","latestBlockHeld","newBlocks","replaceChain","App","useSocket","transports","socket","useState","first","setFirst","useCookies","cookies","setCookie","removeCookie","setPrivateKey","balance","setBalance","setAddress","setAmount","username","setUsername","tempUser","setTempUser","users","setUsers","alert","useAlert","updateBalance","useCallback","refreshBlock","bc","show","refreshTxPool","Tx","connect","useEffect","jerry","emit","publicKey","on","TxPool","obj","left","Container","Card","CardImg","src","require","CardBody","className","InputGroup","Input","type","onChange","e","target","InputGroupAddon","addonType","Button","onClick","Row","Col","md","Label","classnames","InputGroupText","placeholder","parseInt","error","user","Hero","lg","React","Component","Index","document","documentElement","scrollTop","scrollingElement","refs","main","ref","options","timeout","position","positions","BOTTOM_RIGHT","ReactDOM","render","template","AlertTemplate","Helmet","getElementById"],"mappings":"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","file":"static/js/main.b2a3cfaf.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/ultimateJerry.7b5461f3.gif\";","import * as CryptoJS from 'crypto-js';\nimport * as ecdsa from 'elliptic';\nimport * as _ from 'lodash';\n\nconst ec = new ecdsa.ec('secp256k1');\n\nconst COINBASE_AMOUNT: number = 50;\n\nclass UnspentTxOut {\n    public readonly txOutId: string;\n    public readonly txOutIndex: number;\n    public readonly address: string;\n    public readonly amount: number;\n\n    constructor(txOutId: string, txOutIndex: number, address: string, amount: number) {\n        this.txOutId = txOutId;\n        this.txOutIndex = txOutIndex;\n        this.address = address;\n        this.amount = amount;\n    }\n}\n\nclass TxIn {\n    public txOutId: string;\n    public txOutIndex: number;\n    public signature: string;\n}\n\nclass TxOut {\n    public address: string;\n    public amount: number;\n\n    constructor(address: string, amount: number) {\n        this.address = address;\n        this.amount = amount;\n    }\n}\n\nclass Transaction {\n\n    public id: string;\n\n    public txIns: TxIn[];\n    public txOuts: TxOut[];\n}\n\nconst getTransactionId = (transaction: Transaction): string => {\n    const txInContent: string = transaction.txIns\n        .map((txIn: TxIn) => txIn.txOutId + txIn.txOutIndex)\n        .reduce((a, b) => a + b, '');\n\n    const txOutContent: string = transaction.txOuts\n        .map((txOut: TxOut) => txOut.address + txOut.amount)\n        .reduce((a, b) => a + b, '');\n\n    return CryptoJS.SHA256(txInContent + txOutContent).toString();\n};\n\nconst validateTransaction = (transaction: Transaction, aUnspentTxOuts: UnspentTxOut[]): boolean => {\n\n    if (!isValidTransactionStructure(transaction)) {\n        return false;\n    }\n\n    if (getTransactionId(transaction) !== transaction.id) {\n        console.log('invalid tx id: ' + transaction.id);\n        return false;\n    }\n    const hasValidTxIns: boolean = transaction.txIns\n        .map((txIn) => validateTxIn(txIn, transaction, aUnspentTxOuts))\n        .reduce((a, b) => a && b, true);\n\n    if (!hasValidTxIns) {\n        console.log('some of the txIns are invalid in tx: ' + transaction.id);\n        return false;\n    }\n\n    const totalTxInValues: number = transaction.txIns\n        .map((txIn) => getTxInAmount(txIn, aUnspentTxOuts))\n        .reduce((a, b) => (a + b), 0);\n\n    const totalTxOutValues: number = transaction.txOuts\n        .map((txOut) => txOut.amount)\n        .reduce((a, b) => (a + b), 0);\n\n    if (totalTxOutValues !== totalTxInValues) {\n        console.log('totalTxOutValues !== totalTxInValues in tx: ' + transaction.id);\n        return false;\n    }\n\n    return true;\n};\n\nconst validateBlockTransactions = (aTransactions: Transaction[], aUnspentTxOuts: UnspentTxOut[], blockIndex: number): boolean => {\n    const coinbaseTx = aTransactions[0];\n    if (!validateCoinbaseTx(coinbaseTx, blockIndex)) {\n        console.log('invalid coinbase transaction: ' + JSON.stringify(coinbaseTx));\n        return false;\n    }\n\n    // check for duplicate txIns. Each txIn can be included only once\n    // const txIns: TxIn[] = _(aTransactions)\n    //     .map((tx) => tx.txIns)\n    //     .flatten()\n    //     .value();\n\n    // if (hasDuplicates(txIns)) {\n    //     return false;\n    // }\n\n    // all but coinbase transactions\n    const normalTransactions: Transaction[] = aTransactions.slice(1);\n    return normalTransactions.map((tx) => validateTransaction(tx, aUnspentTxOuts))\n        .reduce((a, b) => (a && b), true);\n\n};\n\nconst hasDuplicates = (txIns: TxIn[]): boolean => {\n    const groups = _.countBy(txIns, (txIn: TxIn) => txIn.txOutId + txIn.txOutIndex);\n    return _(groups)\n        .map((value, key) => {\n            if (value > 1) {\n                console.log('duplicate txIn: ' + key);\n                return true;\n            } else {\n                return false;\n            }\n        })\n        .includes(true);\n};\n\nconst validateCoinbaseTx = (transaction: Transaction, blockIndex: number): boolean => {\n    if (transaction == null) {\n        console.log('the first transaction in the block must be coinbase transaction');\n        return false;\n    }\n    if (getTransactionId(transaction) !== transaction.id) {\n        console.log('invalid coinbase tx id: ' + transaction.id);\n        return false;\n    }\n    if (transaction.txIns.length !== 1) {\n        console.log('one txIn must be specified in the coinbase transaction');\n        return;\n    }\n    if (transaction.txIns[0].txOutIndex !== blockIndex) {\n        console.log('the txIn signature in coinbase tx must be the block height');\n        return false;\n    }\n    if (transaction.txOuts.length !== 1) {\n        console.log('invalid number of txOuts in coinbase transaction');\n        return false;\n    }\n    if (transaction.txOuts[0].amount !== COINBASE_AMOUNT) {\n        console.log('invalid coinbase amount in coinbase transaction');\n        return false;\n    }\n    return true;\n};\n\nconst validateTxIn = (txIn: TxIn, transaction: Transaction, aUnspentTxOuts: UnspentTxOut[]): boolean => {\n    const referencedUTxOut: UnspentTxOut =\n        aUnspentTxOuts.find((uTxO) => uTxO.txOutId === txIn.txOutId && uTxO.txOutIndex === txIn.txOutIndex);\n    if (referencedUTxOut == null) {\n        console.log('referenced txOut not found: ' + JSON.stringify(txIn));\n        return false;\n    }\n    const address = referencedUTxOut.address;\n\n    const key = ec.keyFromPublic(address, 'hex');\n    const validSignature: boolean = key.verify(transaction.id, txIn.signature);\n    if (!validSignature) {\n        console.log('invalid txIn signature: %s txId: %s address: %s', txIn.signature, transaction.id, referencedUTxOut.address);\n        return false;\n    }\n    return true;\n};\n\nconst getTxInAmount = (txIn: TxIn, aUnspentTxOuts: UnspentTxOut[]): number => {\n    return findUnspentTxOut(txIn.txOutId, txIn.txOutIndex, aUnspentTxOuts).amount;\n};\n\nconst findUnspentTxOut = (transactionId: string, index: number, aUnspentTxOuts: UnspentTxOut[]): UnspentTxOut => {\n    return aUnspentTxOuts.find((uTxO) => uTxO.txOutId === transactionId && uTxO.txOutIndex === index);\n};\n\nconst getCoinbaseTransaction = (address: string, blockIndex: number): Transaction => {\n    const t = new Transaction();\n    const txIn: TxIn = new TxIn();\n    txIn.signature = '';\n    txIn.txOutId = '';\n    txIn.txOutIndex = blockIndex;\n\n    t.txIns = [txIn];\n    t.txOuts = [new TxOut(address, COINBASE_AMOUNT)];\n    t.id = getTransactionId(t);\n    return t;\n};\n\nconst signTxIn = (transaction: Transaction, txInIndex: number,\n                  privateKey: string, aUnspentTxOuts: UnspentTxOut[]): string => {\n    const txIn: TxIn = transaction.txIns[txInIndex];\n\n    const dataToSign = transaction.id;\n    const referencedUnspentTxOut: UnspentTxOut = findUnspentTxOut(txIn.txOutId, txIn.txOutIndex, aUnspentTxOuts);\n    if (referencedUnspentTxOut == null) {\n        console.log('could not find referenced txOut');\n        throw Error();\n    }\n    const referencedAddress = referencedUnspentTxOut.address;\n\n    if (getPublicKey(privateKey) !== referencedAddress) {\n        console.log('trying to sign an input with private' +\n            ' key that does not match the address that is referenced in txIn');\n        throw Error();\n    }\n    const key = ec.keyFromPrivate(privateKey, 'hex');\n    const signature: string = toHexString(key.sign(dataToSign).toDER());\n\n    return signature;\n};\n\nconst updateUnspentTxOuts = (aTransactions: Transaction[], aUnspentTxOuts: UnspentTxOut[]): UnspentTxOut[] => {\n    const newUnspentTxOuts: UnspentTxOut[] = aTransactions\n        .map((t) => {\n            return t.txOuts.map((txOut, index) => new UnspentTxOut(t.id, index, txOut.address, txOut.amount));\n        })\n        .reduce((a, b) => a.concat(b), []);\n\n    const consumedTxOuts: UnspentTxOut[] = aTransactions\n        .map((t) => t.txIns)\n        .reduce((a, b) => a.concat(b), [])\n        .map((txIn) => new UnspentTxOut(txIn.txOutId, txIn.txOutIndex, '', 0));\n\n    const resultingUnspentTxOuts = aUnspentTxOuts\n        .filter(((uTxO) => !findUnspentTxOut(uTxO.txOutId, uTxO.txOutIndex, consumedTxOuts)))\n        .concat(newUnspentTxOuts);\n\n    return resultingUnspentTxOuts;\n};\n\nconst processTransactions = (aTransactions: Transaction[], aUnspentTxOuts: UnspentTxOut[], blockIndex: number) => {\n\n    if (!validateBlockTransactions(aTransactions, aUnspentTxOuts, blockIndex)) {\n        console.log('invalid block transactions');\n        return null;\n    }\n    return updateUnspentTxOuts(aTransactions, aUnspentTxOuts);\n};\n\nconst toHexString = (byteArray): string => {\n    return Array.from(byteArray, (byte: any) => {\n        return ('0' + (byte & 0xFF).toString(16)).slice(-2);\n    }).join('');\n};\n\nconst getPublicKey = (aPrivateKey: string): string => {\n    return ec.keyFromPrivate(aPrivateKey, 'hex').getPublic().encode('hex');\n};\n\nconst isValidTxInStructure = (txIn: TxIn): boolean => {\n    if (txIn == null) {\n        console.log('txIn is null');\n        return false;\n    } else if (typeof txIn.signature !== 'string') {\n        console.log('invalid signature type in txIn');\n        return false;\n    } else if (typeof txIn.txOutId !== 'string') {\n        console.log('invalid txOutId type in txIn');\n        return false;\n    } else if (typeof  txIn.txOutIndex !== 'number') {\n        console.log('invalid txOutIndex type in txIn');\n        return false;\n    } else {\n        return true;\n    }\n};\n\nconst isValidTxOutStructure = (txOut: TxOut): boolean => {\n    if (txOut == null) {\n        console.log('txOut is null');\n        return false;\n    } else if (typeof txOut.address !== 'string') {\n        console.log('invalid address type in txOut');\n        return false;\n    } else if (!isValidAddress(txOut.address)) {\n        console.log('invalid TxOut address');\n        return false;\n    } else if (typeof txOut.amount !== 'number') {\n        console.log('invalid amount type in txOut');\n        return false;\n    } else {\n        return true;\n    }\n};\n\nconst isValidTransactionStructure = (transaction: Transaction) => {\n    if (typeof transaction.id !== 'string') {\n        console.log('transactionId missing');\n        return false;\n    }\n    if (!(transaction.txIns instanceof Array)) {\n        console.log('invalid txIns type in transaction');\n        return false;\n    }\n    if (!transaction.txIns\n            .map(isValidTxInStructure)\n            .reduce((a, b) => (a && b), true)) {\n        return false;\n    }\n\n    if (!(transaction.txOuts instanceof Array)) {\n        console.log('invalid txIns type in transaction');\n        return false;\n    }\n\n    if (!transaction.txOuts\n            .map(isValidTxOutStructure)\n            .reduce((a, b) => (a && b), true)) {\n        return false;\n    }\n    return true;\n};\n\n// valid address is a valid ecdsa public key in the 04 + X-coordinate + Y-coordinate format\nconst isValidAddress = (address: string): boolean => {\n    if (address.length !== 130) {\n        console.log(address);\n        console.log('invalid public key length');\n        return true;\n    } else if (address.match('^[a-fA-F0-9]+$') === null) {\n        console.log('public key must contain only hex characters');\n        return false;\n    } else if (!address.startsWith('04')) {\n        console.log('public key must start with 04');\n        return false;\n    }\n    return true;\n};\n\nexport {\n    processTransactions, signTxIn, getTransactionId, isValidAddress, validateTransaction,\n    UnspentTxOut, TxIn, TxOut, getCoinbaseTransaction, getPublicKey, hasDuplicates,\n    Transaction\n};\n","import {ec} from 'elliptic';\n// import {existsSync, readFileSync, unlinkSync, writeFileSync} from 'fs';\nimport * as _ from 'lodash';\nimport {getPublicKey, getTransactionId, signTxIn, Transaction, TxIn, TxOut, UnspentTxOut} from './transaction';\nimport Cookies from \"js-cookie\";\nconst EC = new ec('secp256k1');\nconst getPrivateFromWallet = (): string => {\n   // const buffer = readFileSync(privateKeyLocation, 'utf8');\n   let cookie = Cookies.get(\"jerry\");\n   console.log(cookie);\n   return cookie; //buffer.toString();\n};\n\nconst getPublicFromWallet = (): string => {\n    const privateKey = getPrivateFromWallet();\n    const key = EC.keyFromPrivate(privateKey, 'hex');\n    console.log(key.getPublic())\n    return key.getPublic().encode('hex');\n};\n\nconst generatePrivateKey = (): string => {\n  \n    const keyPair = EC.genKeyPair();\n    const privateKey = keyPair.getPrivate();\n    return privateKey.toString(16);;\n};\n\nconst initWallet = () => {\n    // let's not override existing private keys\n   // if (existsSync(privateKeyLocation)) {\n\n//    if(cookies.jerry != \"\")  {\n//    return;\n//     }\n//     const newPrivateKey = generatePrivateKey();\n\n//     //writeFileSync(privateKeyLocation, newPrivateKey);\n//     setCookie('jerry', newPrivateKey);\n   // console.log('new wallet with private key created to : %s', privateKeyLocation);\n};\n\nconst deleteWallet = () => {\n    // if (existsSync(privateKeyLocation)) {\n    //     unlinkSync(privateKeyLocation);\n    // }\n};\n\nconst getBalance = (address: string, unspentTxOuts: UnspentTxOut[]): number => {\n    return _(findUnspentTxOuts(address, unspentTxOuts))\n        .map((uTxO: UnspentTxOut) => uTxO.amount)\n        .sum();\n};\n\nconst findUnspentTxOuts = (ownerAddress: string, unspentTxOuts: UnspentTxOut[]) => {\n    return _.filter(unspentTxOuts, (uTxO: UnspentTxOut) => uTxO.address === ownerAddress);\n};\n\nconst findTxOutsForAmount = (amount: number, myUnspentTxOuts: UnspentTxOut[]) => {\n    let currentAmount = 0;\n    const includedUnspentTxOuts = [];\n    for (const myUnspentTxOut of myUnspentTxOuts) {\n        includedUnspentTxOuts.push(myUnspentTxOut);\n        currentAmount = currentAmount + myUnspentTxOut.amount;\n        if (currentAmount >= amount) {\n            const leftOverAmount = currentAmount - amount;\n            return {includedUnspentTxOuts, leftOverAmount};\n        }\n    }\n\n    const eMsg = 'Cannot create transaction from the available unspent transaction outputs.' +\n        ' Required amount:' + amount + '. Available unspentTxOuts:' + JSON.stringify(myUnspentTxOuts);\n    throw Error(eMsg);\n};\n\nconst createTxOuts = (receiverAddress: string, myAddress: string, amount, leftOverAmount: number) => {\n    const txOut1: TxOut = new TxOut(receiverAddress, amount);\n    if (leftOverAmount === 0) {\n        return [txOut1];\n    } else {\n        const leftOverTx = new TxOut(myAddress, leftOverAmount);\n        return [txOut1, leftOverTx];\n    }\n};\n\nconst filterTxPoolTxs = (unspentTxOuts: UnspentTxOut[], transactionPool: Transaction[]): UnspentTxOut[] => {\n    const txIns: TxIn[] = _(transactionPool)\n        .map((tx: Transaction) => tx.txIns)\n        .flatten()\n        .value();\n    const removable: UnspentTxOut[] = [];\n    for (const unspentTxOut of unspentTxOuts) {\n        const txIn = _.find(txIns, (aTxIn: TxIn) => {\n            return aTxIn.txOutIndex === unspentTxOut.txOutIndex && aTxIn.txOutId === unspentTxOut.txOutId;\n        });\n\n        if (txIn === undefined) {\n\n        } else {\n            removable.push(unspentTxOut);\n        }\n    }\n\n    return _.without(unspentTxOuts, ...removable);\n};\n\nconst createTransaction = (receiverAddress: string, amount: number, privateKey: string,\n                           unspentTxOuts: UnspentTxOut[], txPool: Transaction[]): Transaction => {\n\n    console.log('txPool: %s', JSON.stringify(txPool));\n    const myAddress: string = getPublicKey(privateKey);\n    const myUnspentTxOutsA = unspentTxOuts.filter((uTxO: UnspentTxOut) => uTxO.address === myAddress);\n\n    const myUnspentTxOuts = filterTxPoolTxs(myUnspentTxOutsA, txPool);\n\n    // filter from unspentOutputs such inputs that are referenced in pool\n    const {includedUnspentTxOuts, leftOverAmount} = findTxOutsForAmount(amount, myUnspentTxOuts);\n\n    const toUnsignedTxIn = (unspentTxOut: UnspentTxOut) => {\n        const txIn: TxIn = new TxIn();\n        txIn.txOutId = unspentTxOut.txOutId;\n        txIn.txOutIndex = unspentTxOut.txOutIndex;\n        return txIn;\n    };\n\n    const unsignedTxIns: TxIn[] = includedUnspentTxOuts.map(toUnsignedTxIn);\n\n    const tx: Transaction = new Transaction();\n    tx.txIns = unsignedTxIns;\n    tx.txOuts = createTxOuts(receiverAddress, myAddress, amount, leftOverAmount);\n    tx.id = getTransactionId(tx);\n\n    tx.txIns = tx.txIns.map((txIn: TxIn, index: number) => {\n        txIn.signature = signTxIn(tx, index, privateKey, unspentTxOuts);\n        return txIn;\n    });\n\n    return tx;\n};\n\nexport {createTransaction, getPublicFromWallet,\n    getPrivateFromWallet, getBalance, generatePrivateKey, initWallet, deleteWallet, findUnspentTxOuts};\n","import * as _ from 'lodash';\nimport {Transaction, TxIn, UnspentTxOut, validateTransaction} from './transaction';\n\nlet transactionPool: Transaction[] = [];\n\nconst getTransactionPool = () => {\n    return _.cloneDeep(transactionPool);\n};\n\nconst setTransactionPool = ( txPool: Transaction[]) => {\n    transactionPool = txPool;\n}\n\nconst addToTransactionPool = (tx: Transaction, unspentTxOuts: UnspentTxOut[]) => {\n\n    if (!validateTransaction(tx, unspentTxOuts)) {\n        throw Error('Trying to add invalid tx to pool');\n    }\n\n    if (!isValidTxForPool(tx, transactionPool)) {\n        throw Error('Trying to add invalid tx to pool');\n    }\n    console.log('adding to txPool: %s', JSON.stringify(tx));\n    transactionPool.push(tx);\n};\n\nconst hasTxIn = (txIn: TxIn, unspentTxOuts: UnspentTxOut[]): boolean => {\n    const foundTxIn = unspentTxOuts.find((uTxO: UnspentTxOut) => {\n        return uTxO.txOutId === txIn.txOutId && uTxO.txOutIndex === txIn.txOutIndex;\n    });\n    return foundTxIn !== undefined;\n};\n\nconst updateTransactionPool = (unspentTxOuts: UnspentTxOut[]) => {\n    const invalidTxs = [];\n    for (const tx of transactionPool) {\n        for (const txIn of tx.txIns) {\n            if (!hasTxIn(txIn, unspentTxOuts)) {\n                invalidTxs.push(tx);\n                break;\n            }\n        }\n    }\n    if (invalidTxs.length > 0) {\n        console.log('removing the following transactions from txPool: %s', JSON.stringify(invalidTxs));\n        transactionPool = _.without(transactionPool, ...invalidTxs);\n    }\n};\n\nconst getTxPoolIns = (aTransactionPool: Transaction[]): TxIn[] => {\n    return _(aTransactionPool)\n        .map((tx) => tx.txIns)\n        .flatten()\n        .value();\n};\n\nconst isValidTxForPool = (tx: Transaction, aTtransactionPool: Transaction[]): boolean => {\n    const txPoolIns: TxIn[] = getTxPoolIns(aTtransactionPool);\n\n    const containsTxIn = (txIns: TxIn[], txIn: TxIn) => {\n        return _.find(txPoolIns, ((txPoolIn) => {\n            return txIn.txOutIndex === txPoolIn.txOutIndex && txIn.txOutId === txPoolIn.txOutId;\n        }));\n    };\n\n    for (const txIn of tx.txIns) {\n        if (containsTxIn(txPoolIns, txIn)) {\n            console.log('txIn already found in the txPool');\n            return false;\n        }\n    }\n    return true;\n};\n\nexport {setTransactionPool, addToTransactionPool, getTransactionPool, updateTransactionPool};\n","import * as CryptoJS from 'crypto-js';\nimport * as _ from 'lodash';\nimport {\n    getCoinbaseTransaction, isValidAddress, processTransactions, Transaction, UnspentTxOut\n} from './transaction';\nimport {addToTransactionPool, getTransactionPool, updateTransactionPool} from './transactionPool';\nimport {hexToBinary} from './util';\nimport {createTransaction, findUnspentTxOuts, getBalance, getPrivateFromWallet, getPublicFromWallet} from './wallet';\n\nclass Block {\n\n    public index: number;\n    public hash: string;\n    public previousHash: string;\n    public timestamp: number;\n    public data: Transaction[];\n    public difficulty: number;\n    public nonce: number;\n\n    constructor(index: number, hash: string, previousHash: string,\n                timestamp: number, data: Transaction[], difficulty: number, nonce: number) {\n        this.index = index;\n        this.previousHash = previousHash;\n        this.timestamp = timestamp;\n        this.data = data;\n        this.hash = hash;\n        this.difficulty = difficulty;\n        this.nonce = nonce;\n    }\n}\n\nconst genesisTransaction = {\n    'txIns': [{'signature': '', 'txOutId': '', 'txOutIndex': 0}],\n    'txOuts': [{\n        'address': '04bfcab8722991ae774db48f934ca79cfb7dd991229153b9f732ba5334aafcd8e7266e47076996b55a14bf9913ee3145ce0cfc1372ada8ada74bd287450313534a',\n        'amount': 50\n    }],\n    'id': 'e655f6a5f26dc9b4cac6e46f52336428287759cf81ef5ff10854f69d68f43fa3'\n};\n\nconst genesisBlock: Block = new Block(\n    0, '91a73664bc84c0baa1fc75ea6e4aa6d1d20c5df664c724e3159aefc2e1186627', '', 1465154705, [genesisTransaction], 0, 0\n);\n\nlet blockchain: Block[] = [genesisBlock];\n\n// the unspent txOut of genesis block is set to unspentTxOuts on startup\nlet unspentTxOuts: UnspentTxOut[] = processTransactions(blockchain[0].data, [], 0);\n\nconst getBlockchain = (): Block[] => blockchain;\n\nconst setBlockchain = (bc: Block[]) => {\n  blockchain = bc; \n  unspentTxOuts = isValidChain(blockchain);\n};\n\nconst getUnspentTxOuts = (): UnspentTxOut[] => _.cloneDeep(unspentTxOuts);\n\n// and txPool should be only updated at the same time\nconst setUnspentTxOuts = (newUnspentTxOut: UnspentTxOut[]) => {\n    console.log('replacing unspentTxouts with: %s', newUnspentTxOut);\n    unspentTxOuts = newUnspentTxOut;\n};\n\nconst getLatestBlock = (): Block => blockchain[blockchain.length - 1];\n\n// in seconds\nconst BLOCK_GENERATION_INTERVAL: number = 10;\n\n// in blocks\nconst DIFFICULTY_ADJUSTMENT_INTERVAL: number = 5;\n\nconst getDifficulty = (aBlockchain: Block[]): number => {\n    const latestBlock: Block = aBlockchain[blockchain.length - 1];\n    if (latestBlock.index % DIFFICULTY_ADJUSTMENT_INTERVAL === 0 && latestBlock.index !== 0) {\n        return getAdjustedDifficulty(latestBlock, aBlockchain);\n    } else {\n        return latestBlock.difficulty;\n    }\n};\n\nconst getAdjustedDifficulty = (latestBlock: Block, aBlockchain: Block[]) => {\n    const prevAdjustmentBlock: Block = aBlockchain[blockchain.length - DIFFICULTY_ADJUSTMENT_INTERVAL];\n    const timeExpected: number = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;\n    const timeTaken: number = latestBlock.timestamp - prevAdjustmentBlock.timestamp;\n    if (timeTaken < timeExpected / 2) {\n        return prevAdjustmentBlock.difficulty + 1;\n    } else if (timeTaken > timeExpected * 2 && prevAdjustmentBlock.difficulty) {\n        return prevAdjustmentBlock.difficulty - 1;\n    } else {\n        return prevAdjustmentBlock.difficulty;\n    }\n};\n\nconst getCurrentTimestamp = (): number => Math.round(new Date().getTime() / 1000);\n\nconst generateRawNextBlock = (blockData: Transaction[]) => {\n    const previousBlock: Block = getLatestBlock();\n    const difficulty: number = getDifficulty(getBlockchain());\n    const nextIndex: number = previousBlock.index + 1;\n    const nextTimestamp: number = getCurrentTimestamp();\n    const newBlock: Block = findBlock(nextIndex, previousBlock.hash, nextTimestamp, blockData, difficulty);\n    if (addBlockToChain(newBlock)) {\n        return newBlock;\n    } else {\n        return null;\n    }\n\n};\n\n// gets the unspent transaction outputs owned by the wallet\nconst getMyUnspentTransactionOutputs = () => {\n    return findUnspentTxOuts(getPublicFromWallet(), getUnspentTxOuts());\n};\n\nconst generateNextBlock = () => {\n    const coinbaseTx: Transaction = getCoinbaseTransaction(getPublicFromWallet(), getLatestBlock().index + 1);\n    const blockData: Transaction[] = [coinbaseTx].concat(getTransactionPool());\n    return generateRawNextBlock(blockData);\n};\n\nconst generatenextBlockWithTransaction = (receiverAddress: string, amount: number) => {\n    if (!isValidAddress(receiverAddress)) {\n        throw Error('invalid address');\n    }\n    if (typeof amount !== 'number') {\n        throw Error('invalid amount');\n    }\n    const coinbaseTx: Transaction = getCoinbaseTransaction(getPublicFromWallet(), getLatestBlock().index + 1);\n    const tx: Transaction = createTransaction(receiverAddress, amount, getPrivateFromWallet(), getUnspentTxOuts(), getTransactionPool());\n    const blockData: Transaction[] = [coinbaseTx, tx];\n    return generateRawNextBlock(blockData);\n};\n\nconst findBlock = (index: number, previousHash: string, timestamp: number, data: Transaction[], difficulty: number): Block => {\n    let nonce = 0;\n    while (true) {\n        const hash: string = calculateHash(index, previousHash, timestamp, data, difficulty, nonce);\n        if (hashMatchesDifficulty(hash, difficulty)) {\n            return new Block(index, hash, previousHash, timestamp, data, difficulty, nonce);\n        }\n        nonce++;\n    }\n};\n\nconst getAccountBalance = (): number => {\n    return getBalance(getPublicFromWallet(), getUnspentTxOuts());\n};\n\nconst sendTransaction = (address: string, amount: number): Transaction => {\n    const tx: Transaction = createTransaction(address, amount, getPrivateFromWallet(), getUnspentTxOuts(), getTransactionPool());\n    addToTransactionPool(tx, getUnspentTxOuts());\n    return tx;\n};\n\nconst calculateHashForBlock = (block: Block): string =>\n    calculateHash(block.index, block.previousHash, block.timestamp, block.data, block.difficulty, block.nonce);\n\nconst calculateHash = (index: number, previousHash: string, timestamp: number, data: Transaction[],\n                       difficulty: number, nonce: number): string =>\n     CryptoJS.SHA256(index + previousHash + timestamp + data + difficulty + nonce).toString();\n\nconst isValidBlockStructure = (block: Block): boolean => {\n    return typeof block.index === 'number'\n        && typeof block.hash === 'string'\n        && typeof block.previousHash === 'string'\n        && typeof block.timestamp === 'number'\n        && typeof block.data === 'object';\n};\n\nconst isValidNewBlock = (newBlock: Block, previousBlock: Block): boolean => {\n    if (!isValidBlockStructure(newBlock)) {\n        console.log('invalid block structure: %s', JSON.stringify(newBlock));\n        return false;\n    }\n    if (previousBlock.index + 1 !== newBlock.index) {\n        console.log('invalid index');\n        return false;\n    } else if (previousBlock.hash !== newBlock.previousHash) {\n        console.log('invalid previoushash');\n        return false;\n    } else if (!isValidTimestamp(newBlock, previousBlock)) {\n        console.log('invalid timestamp');\n        return false;\n    } else if (!hasValidHash(newBlock)) {\n        return false;\n    }\n    return true;\n};\n\nconst getAccumulatedDifficulty = (aBlockchain: Block[]): number => {\n    return aBlockchain\n        .map((block) => block.difficulty)\n        .map((difficulty) => Math.pow(2, difficulty))\n        .reduce((a, b) => a + b);\n};\n\nconst isValidTimestamp = (newBlock: Block, previousBlock: Block): boolean => {\n    return ( previousBlock.timestamp - 60 < newBlock.timestamp )\n        && newBlock.timestamp - 60 < getCurrentTimestamp();\n};\n\nconst hasValidHash = (block: Block): boolean => {\n\n    if (!hashMatchesBlockContent(block)) {\n        console.log('invalid hash, got:' + block.hash);\n        return false;\n    }\n\n    if (!hashMatchesDifficulty(block.hash, block.difficulty)) {\n        console.log('block difficulty not satisfied. Expected: ' + block.difficulty + 'got: ' + block.hash);\n    }\n    return true;\n};\n\nconst hashMatchesBlockContent = (block: Block): boolean => {\n    const blockHash: string = calculateHashForBlock(block);\n    return blockHash === block.hash;\n};\n\nconst hashMatchesDifficulty = (hash: string, difficulty: number): boolean => {\n    const hashInBinary: string = hexToBinary(hash);\n    const requiredPrefix: string = '0'.repeat(difficulty);\n    return hashInBinary.startsWith(requiredPrefix);\n};\n\n/*\n    Checks if the given blockchain is valid. Return the unspent txOuts if the chain is valid\n */\nconst isValidChain = (blockchainToValidate: Block[]): UnspentTxOut[] => {\n    console.log('isValidChain:');\n    console.log(JSON.stringify(blockchainToValidate));\n    const isValidGenesis = (block: Block): boolean => {\n        return JSON.stringify(block) === JSON.stringify(genesisBlock);\n    };\n\n    if (!isValidGenesis(blockchainToValidate[0])) {\n        return null;\n    }\n    /*\n    Validate each block in the chain. The block is valid if the block structure is valid\n      and the transaction are valid\n     */\n    let aUnspentTxOuts: UnspentTxOut[] = [];\n\n    for (let i = 0; i < blockchainToValidate.length; i++) {\n        const currentBlock: Block = blockchainToValidate[i];\n        if (i !== 0 && !isValidNewBlock(blockchainToValidate[i], blockchainToValidate[i - 1])) {\n            return null;\n        }\n\n        aUnspentTxOuts = processTransactions(currentBlock.data, aUnspentTxOuts, currentBlock.index);\n        if (aUnspentTxOuts === null) {\n            console.log('invalid transactions in blockchain');\n            return null;\n        }\n    }\n    return aUnspentTxOuts;\n};\n\nconst addBlockToChain = (newBlock: Block): boolean => {\n    if (isValidNewBlock(newBlock, getLatestBlock())) {\n        const retVal: UnspentTxOut[] = processTransactions(newBlock.data, getUnspentTxOuts(), newBlock.index);\n        if (retVal === null) {\n            console.log('block is not valid in terms of transactions');\n            return false;\n        } else {\n            blockchain.push(newBlock);\n            setUnspentTxOuts(retVal);\n            updateTransactionPool(unspentTxOuts);\n            return true;\n        }\n    }\n    return false;\n};\n\nconst replaceChain = (newBlocks: Block[]) => {\n    const aUnspentTxOuts = isValidChain(newBlocks);\n    const validChain: boolean = aUnspentTxOuts !== null;\n    if (validChain &&\n        getAccumulatedDifficulty(newBlocks) > getAccumulatedDifficulty(getBlockchain())) {\n        console.log('Received blockchain is valid. Replacing current blockchain with received blockchain');\n        blockchain = newBlocks;\n        setUnspentTxOuts(aUnspentTxOuts);\n        updateTransactionPool(unspentTxOuts);\n    } else {\n        console.log('Received blockchain invalid');\n    }\n};\n\nconst handleReceivedTransaction = (transaction: Transaction) => {\n    addToTransactionPool(transaction, getUnspentTxOuts());\n};\n\nexport { setBlockchain,\n    Block, getBlockchain, getUnspentTxOuts, getLatestBlock, sendTransaction,\n    generateRawNextBlock, generateNextBlock, generatenextBlockWithTransaction,\n    handleReceivedTransaction, getMyUnspentTransactionOutputs,\n    getAccountBalance, isValidBlockStructure, replaceChain, addBlockToChain\n};\n","const hexToBinary = (s: string): string => {\n    let ret: string = '';\n    const lookupTable = {\n        '0': '0000', '1': '0001', '2': '0010', '3': '0011', '4': '0100',\n        '5': '0101', '6': '0110', '7': '0111', '8': '1000', '9': '1001',\n        'a': '1010', 'b': '1011', 'c': '1100', 'd': '1101',\n        'e': '1110', 'f': '1111'\n    };\n    for (let i: number = 0; i < s.length; i = i + 1) {\n        if (lookupTable[s[i]]) {\n            ret += lookupTable[s[i]];\n        } else {\n            return null;\n        }\n    }\n    return ret;\n};\n\nexport {hexToBinary};\n","// import * as WebSocket from 'ws';\n// import {Server} from 'ws';\n\nimport {\n    addBlockToChain, Block, getLatestBlock, isValidBlockStructure,\n    replaceChain\n} from './blockchain';\n\nconst handleBlockchainResponse = (receivedBlocks: Block[]) => {\n    if (receivedBlocks.length === 0) {\n        console.log('received block chain size of 0');\n        return;\n    }\n    const latestBlockReceived: Block = receivedBlocks[receivedBlocks.length - 1];\n    if (!isValidBlockStructure(latestBlockReceived)) {\n        console.log('block structuture not valid');\n        return;\n    }\n    const latestBlockHeld: Block = getLatestBlock();\n    if (latestBlockReceived.index > latestBlockHeld.index) {\n        console.log('blockchain possibly behind. We got: '\n            + latestBlockHeld.index + ' Peer got: ' + latestBlockReceived.index);\n        if (latestBlockHeld.hash === latestBlockReceived.previousHash) {\n            if (addBlockToChain(latestBlockReceived)) {\n            }\n        } else if (receivedBlocks.length === 1) {\n            console.log('We have to query the chain from our peer');\n        } else {\n            console.log('Received blockchain is longer than current blockchain');\n            replaceChain(receivedBlocks);\n        }\n    } else {\n        console.log('received blockchain is not longer than received blockchain. Do nothing');\n    }\n};\n\n\n\nexport {handleBlockchainResponse};\n","import React, { useState, useEffect, useCallback } from \"react\";\nimport \"./App.css\";\nimport { generatePrivateKey, getPublicFromWallet } from \"./crypto/wallet\";\nimport {\n  sendTransaction,\n  generateNextBlock,\n  getAccountBalance,\n  getBlockchain\n} from \"./crypto/blockchain\";\nimport { useCookies } from \"react-cookie\";\nimport { setTransactionPool } from \"./crypto/transactionPool\";\nimport { handleBlockchainResponse } from \"./crypto/p2p\";\nimport {\n  Button,\n  Card,\n  CardBody,\n  CardImg,\n  Input,\n  Label,\n  InputGroupAddon,\n  InputGroupText,\n  InputGroup,\n  Container,\n  Row,\n  Col\n} from \"reactstrap\";\nimport useSocket from \"use-socket.io-client\";\nimport { useAlert } from \"react-alert\";\nimport QRCode from \"qrcode.react\";\n\nfunction App() {\n  const [socket] = useSocket(\"https://jerry-server.herokuapp.com\", {\n    transports: [\"websocket\"]\n  });\n  const [first, setFirst] = useState(true);\n  const [cookies, setCookie, removeCookie] = useCookies([\"jerry\"]);\n  const [privateKey, setPrivateKey] = useState(\"\");\n  const [balance, setBalance] = useState(0); \n  const [address, setAddress] = useState(\"\");\n  const [amount, setAmount] = useState(0);\n  const [username, setUsername] = useState(\"\");\n  const [tempUser, setTempUser] = useState(\"\");\n  const [users, setUsers] = useState([]);\n  const alert = useAlert();\n\n  let updateBalance = useCallback(() => {\n    setBalance(getAccountBalance());\n  }, [setBalance]);\n\n  let refreshBlock = useCallback(\n    bc => {\n      alert.show(\"Got New Block #\" + bc.length);\n      console.log(bc);\n\n      handleBlockchainResponse(bc);\n      updateBalance();\n    },\n    [alert, updateBalance]\n  );\n\n  let refreshTxPool = useCallback(\n    Tx => {\n      console.log(Tx);\n      alert.show(\"Got New Transaction Pool\");\n      setTransactionPool(Tx);\n    },\n    [alert]\n  );\n\n  socket.connect();\n\n  // Similar to componentDidMount and componentDidUpdate:\n  useEffect(() => {\n    if (cookies.jerry === undefined) {\n      let key = generatePrivateKey();\n      console.log(\"making key\", key);\n      setCookie(\"jerry\", key);\n\n      setPrivateKey(getPublicFromWallet());\n    } else {\n      console.log(cookies.jerry);\n      setPrivateKey(getPublicFromWallet());\n    } //Very simply connect to the socket\n    //Listen for data on the \"outgoing data\" namespace and supply a callback for what to do when we get one. In this case, we set a state variable\n    if (first && username !== \"\") {\n      console.log(\"running first\");\n      socket.emit(\"getTxPool\");\n      socket.emit(\"getBlockchain\");\n      socket.emit(\"setUser\", {\n        username: username,\n        publicKey: privateKey\n      });\n      setFirst(false);\n      socket.on(\"resTxPool\", TxPool => {\n        console.log(\"got pool:\", TxPool);\n        refreshTxPool(TxPool);\n      });\n      socket.on(\"resBlockchain\", bc => {\n        console.log(\"got bc:\", bc);\n        refreshBlock(bc);\n      });\n\n      socket.on(\"tx\", TxPool => {\n        console.log(\"got pool:\", TxPool);\n        refreshTxPool(TxPool);\n      });\n      socket.on(\"bc\", bc => {\n        console.log(\"got bc:\", bc);\n        refreshBlock(bc);\n      });\n      socket.on(\"users\", users => {\n        console.log(users);\n\n        users = users.filter(function(obj) {\n          return obj.username !== username;\n        });\n        alert.show(\"New User Joined\");\n        console.log(users);\n        setUsers(users);\n      });\n      socket.on(\"userLeft\", users => {\n        console.log(users);\n\n        users.users = users.users.filter(function(obj) {\n          return obj.username !== username;\n        });\n        alert.show(\"user \" + users.left + \" left\");\n        console.log(users.users);\n        setUsers(users.users);\n      });\n    }\n  }, [\n    cookies,\n    privateKey,\n    first,\n    setBalance,\n    setPrivateKey,\n    removeCookie,\n    setCookie,\n    refreshBlock,\n    refreshTxPool,\n    socket,\n    username,\n    alert\n  ]);\n\n  return (\n    <>\n      <Container>\n        <Card>\n          <CardImg src={require(\"./assets/ultimateJerry.gif\")} />\n          <CardBody>\n            <h1 className=\"display-3\"> JerryCoin </h1>\n            <h6 className=\"lead\">\n              This is JerryCoin, a decentralized, consensus-based\n              cryptocurrency, based right here on the web.\n            </h6>\n          </CardBody>\n        </Card>\n\n        <hr className=\"my-2\" />\n\n        {username === \"\" && (\n          <>\n            <InputGroup>\n              <Input\n                type=\"text\"\n                onChange={e => {\n                  setTempUser(e.target.value);\n                }}\n              />\n              <InputGroupAddon addonType=\"append\">\n                <Button\n                  onClick={() => {\n                    setUsername(tempUser);\n                  }}\n                >\n                  Set Username\n                </Button>\n              </InputGroupAddon>\n            </InputGroup>\n          </>\n        )}\n\n        {username !== \"\" && (\n          <>\n         <Card><h6 className=\"lead\"> Public Key: {privateKey} </h6></Card>\n            <br/>\n            <Card><h6 className=\"lead\">Balance: {balance} </h6></Card>\n            <br/>\n            <Row>\n              <Col md=\"3\">\n                <Label>\n                  <p classnames=\"text-white\"> Send Address </p>\n                </Label>\n              </Col>\n              <Col md=\"9\"></Col>\n            </Row>\n\n            <InputGroup>\n              <InputGroupAddon addonType=\"prepend\">\n                <InputGroupText>@</InputGroupText>\n              </InputGroupAddon>\n              <Input\n                type=\"text\"\n                value={address}\n                placeholder=\"04234adfasdfae9342...\"\n                onChange={e => setAddress(e.target.value)}\n              />\n            </InputGroup>\n\n            <br></br>\n            <Row>\n              <Col md=\"2\">\n                <Label>\n                  <p classnames=\"text-white\"> Amount To Send </p>\n                </Label>\n              </Col>\n              <Col md=\"10\"></Col>\n            </Row>\n            <InputGroup>\n              <InputGroupAddon>\n                <InputGroupText>₵</InputGroupText>\n              </InputGroupAddon>\n              <Input\n                value={amount}\n                onChange={e => {\n                  let amount;\n                  if (e.target.value === \"\") {\n                    amount = 0;\n                  } else {\n                    amount = parseInt(e.target.value);\n                  }\n                  setAmount(amount);\n                }}\n              />\n              <InputGroupAddon addonType=\"append\">\n                <Button\n                  onClick={() => {\n                    let tx;\n                    try {\n                     tx = sendTransaction(address, amount)\n                      socket.emit(\"sendTx\", tx);\n\n                    } catch(e) {\n                      console.log(e)\n                      alert.error(\"You dont have enough coins\")\n                    }\n                  }}\n                >\n                  Send JC\n                </Button>\n              </InputGroupAddon>\n            </InputGroup>\n\n            <Row>\n              <Col className=\"my-3\" md=\"6\">\n                <QRCode value={privateKey} />\n              </Col>\n              <Col className=\"my-3\" md=\"6\">\n                <Button\n                  onClick={() => {\n                    generateNextBlock();\n                    setBalance(getAccountBalance());\n                    socket.emit(\"sendBlockchain\", getBlockchain());\n                  }}\n                >\n                  Generate Block\n                </Button>\n              </Col>\n            </Row>\n\n              <p>Click On Users To Load Their Address:</p>\n              {users.map(user => {\n                return (\n                  <Card\n                    onClick={() => {\n                      setAddress(user.publicKey);\n                    }}\n                  >\n                    <h6> {user.username} </h6>\n                  </Card>\n                );\n              })}\n\n            \n          </>\n        )}\n      </Container>\n    </>\n  );\n}\n\nexport default App;\n","\nimport React from \"react\";\n\n// reactstrap components\nimport { Container, Row, Col } from \"reactstrap\";\nimport App from \"../../App\"\n\n\nclass Hero extends React.Component {\n  render() {\n    return (\n      <>\n        <div className=\"position-relative\">\n          {/* Hero for FREE version */}\n          <section className=\"section section-lg section-hero section-shaped\">\n            {/* Background circles */}\n            <div className=\"shape shape-style-1 shape-default\">\n              \n              <span className=\"span-100\" />\n              <span className=\"span-100\" />\n              <span className=\"span-100\" />\n              <span className=\"span-100\" />\n              <span className=\"span-100\" />\n              <span className=\"span-100\" />\n              <span className=\"span-100\" />\n\n              <span className=\"span-75\" />\n              <span className=\"span-50\" />\n              <span className=\"span-100\" />\n              <span className=\"span-50\" />\n              <span className=\"span-100\" />\n            </div>\n            <Container className=\"shape-container d-flex align-items-center \">\n              <div className=\"col px-0\">\n                <Row className=\"align-items-center justify-content-center\">\n                  <Col className=\"text-center\" lg=\"8\">\n\n                    <App />\n\n                  </Col>\n                </Row>\n              </div>\n            </Container>\n          \n          </section>\n        </div>\n      </>\n    );\n  }\n}\n\nexport default Hero;\n","/*!\n\n=========================================================\n* Argon Design System React - v1.0.0\n=========================================================\n\n* Product Page: https://www.creative-tim.com/product/argon-design-system-react\n* Copyright 2019 Creative Tim (https://www.creative-tim.com)\n* Licensed under MIT (https://github.com/creativetimofficial/argon-design-system-react/blob/master/LICENSE.md)\n\n* Coded by Creative Tim\n\n=========================================================\n\n* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n*/\nimport React from \"react\";\n// index page sections\nimport Hero from \"./IndexSections/Hero.jsx\";\n\n\nclass Index extends React.Component {\n  componentDidMount() {\n    document.documentElement.scrollTop = 0;\n    document.scrollingElement.scrollTop = 0;\n    this.refs.main.scrollTop = 0;\n  }\n  render() {\n    return (\n      <>\n        <main ref=\"main\">\n          <Hero />\n         \n        </main>\n      </>\n    );\n  }\n}\n\nexport default Index;\n","\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Helmet } from 'react-helmet';\n\nimport \"./assets/vendor/nucleo/css/nucleo.css\";\nimport \"./assets/vendor/font-awesome/css/font-awesome.min.css\";\nimport \"./assets/css/argon-design-system-react.css\";\n\nimport Index from \"./views/Index.jsx\";\n\nimport { positions, Provider } from \"react-alert\";\nimport AlertTemplate from \"react-alert-template-basic\";\n\nconst options = {\n  timeout: 1500,\n  position: positions.BOTTOM_RIGHT\n};\n\nReactDOM.render(\n<Provider template={AlertTemplate} {...options}>\n<Helmet>\n          <title>JerryCoin</title>\n        </Helmet>\n<Index/>\n  </Provider>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}